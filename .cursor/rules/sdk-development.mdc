---
description: Rules for SDK development and maintenance in the pkg/sdk directory
globs:
  - "pkg/sdk/**/*.go"
alwaysApply: false
---

# SDK Development Rules

You are working on the Snowflake SDK that provides Go types and methods for interacting with Snowflake APIs.

**Scope**: This document covers SDK architecture, development patterns, data conventions, testing strategy, and Snowflake-specific patterns.

**Related**: For SDK object implementation using the generator, see [SDK Generator Rules](sdk-generator.mdc).

## SDK Architecture

The Snowflake SDK is organized around a centralized Client structure that provides access to all Snowflake object operations through typed interfaces. The SDK uses a hybrid approach combining code generation for newer objects and manual implementation for legacy objects.

### Core Components

**Client Structure** (`client.go`):
- Central hub providing access to all Snowflake object types
- Organizes operations into logical groups (DDL Commands, System Functions)
- Each object type exposed as a field (e.g., `client.Databases`, `client.Users`)
- Initialized with all object implementations in `initialize()` method

**Object Types** (`object_types.go`):
- Centralized registry of all supported Snowflake object types
- Maps singular to plural forms for SQL generation
- Provides identifier type resolution for different object hierarchies
- Currently supports 50+ object types from Account to Services

### File Organization Patterns

**Generated Objects** (New objects using SDK generator):
- `*_def.go` - Object definition using generator DSL (e.g., `applications_def.go`)
- `*_gen.go` - Generated interfaces and option structs
- `*_dto_gen.go` - Generated request DTOs
- `*_dto_builders_gen.go` - Generated DTO constructors and builders
- `*_impl_gen.go` - Generated interface implementations
- `*_validations_gen.go` - Generated validation logic
- `*_gen_test.go` - Generated unit test placeholders
- `*_ext.go` - Manual extensions to generated code (when needed)

**Manual Objects** (Legacy objects written by hand):
- `*.go` - Combined interface, implementation, and types (e.g., `databases.go`)
- No `_def.go` file
- Manual DTO definitions with `//go:generate` for builders
- Manual validation and test implementations

**Integration Tests**:
- Located in `testint/` subdirectory
- Always manually written (never generated)
- Follow pattern `*_integration_test.go`

### Code Generation System

**SDK Generator** (`pkg/sdk/poc/`):
- Template-based code generation from DSL definitions
- Generates 5 main file types per object definition
- Uses Go generate directives: `//go:generate go run ./poc/main.go`
- Supports complex validation, SQL generation, and type mapping
- Still considered PoC but widely used for new objects

**DTO Builder Generator** (`pkg/sdk/dto-builder-generator/`):
- Generates constructor and builder methods for DTO structs
- Uses Go generate directive: `//go:generate go run ./dto-builder-generator/main.go`
- Identifies required fields via `// required` comments
- Separate from main SDK generator

### Object Implementation Patterns

**Interface Design**:
- Each object type implements a standard interface (Create, Alter, Drop, Show, etc.)
- Common methods: `ShowByID()`, `ShowByIDSafely()`, `DropSafely()`
- Context-aware operations with `context.Context` parameter

**Identifier System**:
- Typed identifiers based on Snowflake hierarchy
- `AccountObjectIdentifier` - Account-level objects (databases, warehouses, users)
- `DatabaseObjectIdentifier` - Database-level objects (schemas)
- `SchemaObjectIdentifier` - Schema-level objects (tables, views, functions)

**SQL Generation**:
- DDL tag system for struct-to-SQL conversion
- Tags: `ddl:"static"`, `ddl:"keyword"`, `ddl:"identifier"`, `ddl:"parameter"`, `ddl:"list"`
- Supports complex SQL generation with parentheses, quotes, and separators

## Adding New SDK Objects

For new Snowflake objects, prefer the code generation approach over manual implementation:

**Implementation Workflow:**
- **Primary Reference**: Follow [SDK Generator Rules](./sdk-generator.mdc) for complete implementation workflow
- Add object to Client struct and initialize it in `initialize()` method
- Update `object_types.go` registry with new object type if needed
- Add manual extensions in `*_ext.go` files only when necessary

## Data Type Conventions

**Nullable Fields**:
- Use pointer types (`*string`, `*int`, `*bool`) for optional/nullable fields
- Use `sdk.String()`, `sdk.Int()`, `sdk.Bool()`, `sdk.Pointer()` helpers for pointer creation
- Handle nil values appropriately in conversion methods

**Enums and Constants**:
- Define enum types as custom string types (e.g., `type TaskState string`)
- Use const blocks for enum values with clear naming patterns
- Define a slice of all enum values under (e.g., `var AllTaskStates = []TaskState { ... }`) as it's used in places like conversion method or documentation generation
- Implement `To<EnumType>(string)` conversion methods with validation
- Test conversion methods thoroughly, including error cases
- Use `ListingState` enum and `ToListingState` method as implementation example

**Identifier Conventions**:
- Use typed identifiers based on Snowflake object hierarchy
- Validation is auto-generated by the SDK generator
- Use `FullyQualifiedName()` method for SQL representation
- Implement `ID()` method returning appropriate identifier type

## Error Handling

**SDK Error Types**:
- Define custom error types for different error categories
- Wrap Snowflake API errors with additional context using error wrapping
- Use error constants for common error patterns to enable error checking
- Provide meaningful error messages that help with debugging

**Error Patterns**:
- Check for specific Snowflake error codes when handling API responses
- Return structured errors that can be programmatically handled
- Include object identifiers and operation context in error messages

## Testing Strategy

**Testing Approach:**
- **Generated Tests**: SDK generator creates basic unit test structure
- **Manual Completion**: Developers complete generated TODOs and add comprehensive coverage
- **Integration Tests**: Manual implementation against real Snowflake instances

**Test File Organization:**
- **Unit Tests**: Generated in `*_gen_test.go` files, completed manually
- **Integration Tests**: Manual implementation in `testint/` directory
- **Build Constraints**: Use `//go:build !account_level_tests` by default

## Unit Testing Requirements

**Generated Test Structure:**
The SDK generator creates unit test templates that must be completed manually:

```go
func TestObjects_Create(t *testing.T) {
    id := randomSchemaObjectIdentifier()

    // Minimal valid options - MUST BE COMPLETED
    defaultOpts := func() *CreateObjectOptions {
        return &CreateObjectOptions{
            name: id,
            // Add other required fields based on Snowflake documentation
        }
    }

    t.Run("validation: nil options", func(t *testing.T) {
        // Auto-generated validation test
    })

    t.Run("basic", func(t *testing.T) {
        opts := defaultOpts()
        // TODO: fill me - MUST be replaced with expected SQL
        assertOptsValidAndSQLEquals(t, opts, "CREATE OBJECT %s", id.FullyQualifiedName())
    })

    t.Run("all options", func(t *testing.T) {
        opts := defaultOpts()
        // TODO: fill me - MUST test comprehensive option combinations
        assertOptsValidAndSQLEquals(t, opts, "CREATE OBJECT %s COMMENT = 'test'", id.FullyQualifiedName())
    })
}
```

**Manual Completion Requirements:**
- **Replace ALL TODO comments** with actual expected SQL
- **Test basic case** with minimal required parameters
- **Test comprehensive case** with all optional parameters set
- **Verify SQL syntax** matches official Snowflake documentation exactly
- **Test validation cases** for conflicting options and required fields
- **Use realistic values** not placeholder text

**Additional Manual Unit Tests:**
Beyond generated tests, add manual tests for:
- Enum conversion methods and error cases
- Custom helper functions and utilities
- SQL generation edge cases
- Complex validation logic not covered by generated tests

## Integration Testing Requirements

**Integration Test Structure:**
```go
//go:build !account_level_tests  // or account_level_tests for account operations

func TestInt_Objects(t *testing.T) {
    client := testClient(t)
    ctx := testContext(t)

    // Helper functions for test resource management
    createObject := func(t *testing.T) (*sdk.Object, func()) {
        t.Helper()
        id := testClientHelper().Ids.RandomSchemaObjectIdentifier()
        req := sdk.NewCreateObjectRequest(id)
        err := client.Objects.Create(ctx, req)
        require.NoError(t, err)

        object, err := client.Objects.ShowByID(ctx, id)
        require.NoError(t, err)

        cleanup := func() {
            err := testClientHelper().Object.DropObjectFunc(t, id)()
            require.NoError(t, err)
        }

        return object, cleanup
    }

    t.Run("create and show", func(t *testing.T) {
        object, cleanup := createObject(t)
        t.Cleanup(cleanup)

        // Test object was created correctly
        assert.Equal(t, expectedValue, object.Field)
    })

    // Test privilege requirements and edge cases
    t.Run("privilege requirements", func(t *testing.T) {
        // Document and test required privileges
        // Test with insufficient privileges where applicable
    })
}
```

**Integration Test Implementation:**
- **Use `testClient()` and `testContext()`** for setup
- **Implement proper cleanup** with `t.Cleanup()`
- **Test all CRUD operations** comprehensively
- **Test privilege requirements** and edge cases
- **Use helper functions** from `testClientHelper()` for common operations
- **Test error scenarios** and insufficient privilege cases

**Test Resource Management:**
- **Create helper functions** for test resource creation and cleanup
- **Use test client** for creating prerequisite objects
- **Clean up test resources** properly to avoid test pollution
- **Group similar assertions** using helper functions
- **Use generated assertions** from `pkg/acceptance/bettertestspoc/assert/objectassert/`

**Test Organization Standards:**
- **Group tests by operation type** (Create, Alter, Drop, Show)
- **Use table-driven tests** for multiple configuration scenarios
- **Include both positive and negative test cases**
- **Document special test requirements** and setup needs
- **Test comprehensive option coverage** for all operations

**Privilege and Edge Case Testing:**
- **Document privilege requirements** in test comments
- **Test with different role configurations** where applicable
- **Verify error handling** for insufficient privileges
- **Test ownership transfer scenarios** when relevant
- **Cover account vs object-level privilege differences**

## Snowflake-Specific Patterns

**Object Hierarchies**:
- Respect Snowflake's three-tier hierarchy: Account > Database > Schema > Object
- Use appropriate identifier types for each hierarchy level
- Account-level: `AccountObjectIdentifier` (databases, warehouses, users)
- Database-level: `DatabaseObjectIdentifier` (schemas)
- Schema-level: `SchemaObjectIdentifier` (tables, views)
- Schema-level with data types as arguments: `SchemaObjectIdentifierWithArguments` (functions, procedures)

**SQL Generation System**:
- Automatic SQL generation from Go structs using DDL tag system
- Core philosophy: Map Snowflake SQL syntax directly to Go struct tags
- **Implementation Details**: See [DDL Tag System](sdk-generator.mdc#dsl-patterns-and-ddl-tag-system) for comprehensive usage
- Validation: Generated SQL must match official Snowflake documentation exactly
