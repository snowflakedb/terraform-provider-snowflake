---
description: Rules for using the SDK generator to create Snowflake object definitions
globs:
  - "pkg/sdk/**/*_def.go"
  - "pkg/sdk/poc/**/*.go"
alwaysApply: false
---

# SDK Generator Usage

You are working with the SDK generator that creates Go types and methods for Snowflake SQL commands using a custom DSL.

**Scope**: This document covers the SDK generator workflow, DSL patterns, DDL tag system, testing requirements, and best practices for implementing new SDK objects.

**Prerequisites**: Understand the SDK architecture and patterns from [SDK Development Rules](sdk-development.mdc) before using the generator.

## Creating SDK Object Definitions

### Definition File Structure
Create `<object_name>_def.go` files with this pattern:

```go
package sdk

import g "github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/sdk/poc/generator"

//go:generate go run ./poc/main.go

// Define output structures separately above the main definition
var objectDbRow = g.DbStruct("objectDBRow").
    Text("created_on").
    Text("name").
    Text("owner").
    Text("comment")

var object = g.PlainStruct("Object").
    Time("CreatedOn").
    Text("Name").
    Text("Owner").
    Text("Comment")

var describeObjectDbRow = g.DbStruct("describeObjectDBRow").
    Text("property").
    Text("value")

var objectDetails = g.PlainStruct("ObjectDetails").
    Text("Property").
    Text("Value")

var ObjectsDef = g.NewInterface(
    "Objects",           // Interface name (plural)
    "Object",           // Struct name (singular)
    g.KindOfT[SchemaObjectIdentifier](), // Identifier type
).
CreateOperation("https://docs.snowflake.com/...",
    g.NewQueryStruct("CreateObject").
        Create().
        SQL("OBJECT").
        Name().
        OptionalComment(),
).
ShowOperation("https://docs.snowflake.com/...",
    objectDbRow, object,
    g.NewQueryStruct("ShowObjects").
        Show().
        SQL("OBJECTS").
        OptionalLike().
        OptionalExtendedIn(),
).
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,
    g.ShowByIDExtendedInFiltering,
).
DescribeOperation(
    g.DescriptionMappingKindSingleValue,
    "https://docs.snowflake.com/...",
    describeObjectDbRow,
    objectDetails,
    g.NewQueryStruct("DescribeObject").
        Describe().
        SQL("OBJECT").
        Name(),
)
```

### DSL Guidelines

**Documentation-Based Development:**
- Use Snowflake documentation as the source of truth
- Map SQL syntax directly to DSL operations
- Include documentation URLs in operation definitions
- **CRITICAL**: When creating SDK definitions from Snowflake documentation, examine the EXACT syntax from the specific command documentation pages
- **Documentation Verification Workflow**:
  1. **Verify each documentation URL** is accessible and contains expected content
  2. **Check for "Syntax" sections** with command structure
  3. **Check for "Output" sections** with field specifications for query commands like SHOW or DESC
  4. **Ask for help** if any links are broken or sections are missing
  5. **Never proceed** with made-up fields or syntax
- **Documentation Parsing**: Always check nested links like:
  - `https://docs.snowflake.com/en/sql-reference/sql/create-dataset` for CREATE DATASET syntax
  - `https://docs.snowflake.com/en/sql-reference/sql/alter-dataset` for ALTER DATASET syntax
  - `https://docs.snowflake.com/en/sql-reference/sql/show-datasets` for SHOW DATASETS syntax
  - `https://docs.snowflake.com/en/sql-reference/sql/desc-dataset` for DESCRIBE DATASET output
- **Syntax Accuracy**: Only include fields and options that are explicitly documented in the "Syntax" section
- **Output Accuracy**: Only include output fields that are explicitly documented in the "Output" section
- **Conservative Approach**: When in doubt, ask for clarification rather than making assumptions

**DSL Patterns and DDL Tag System**

The SDK uses a sophisticated DDL tag system to generate SQL from Go structs. Understanding these patterns is crucial for accurate implementation:

**Core DDL Tags:**
- `ddl:"static"` - Fixed SQL keywords (e.g., `CREATE`, `ALTER`, `DROP`)
- `ddl:"keyword"` - Dynamic keywords with optional quoting and parentheses
- `ddl:"parameter"` - Parameter assignments with `KEY = value` syntax
- `ddl:"identifier"` - Snowflake object identifiers with proper escaping
- `ddl:"list"` - Collections with configurable separators and parentheses

**SQL Generation Modifiers:**
- Quoting: `single_quotes`, `double_quotes`, `no_quotes`, `double_dollar_quotes`
- Parentheses: `parentheses`, `no_parentheses`, `must_parentheses`
- Equals: `no_equals` (for identifiers and special cases)
- Separators: `comma`, `no_comma` (for lists)
- Reverse: `reverse` (for reversed parameter syntax)

**DSL Method Mapping:**
- `SQL("TEXT")` → `ddl:"static" sql:"TEXT"`
- `OptionalSQL("TEXT")` → `ddl:"keyword" sql:"TEXT"` (optional field)
- `TextAssignment("FIELD", options)` → `ddl:"parameter" sql:"FIELD"`
- `Name()` → `ddl:"identifier"` with appropriate identifier type
- `OptionalComment()` → `ddl:"parameter,single_quotes" sql:"COMMENT"`

**Complex Pattern Examples:**
```go
// Generates: ALLOWED_VALUES ('value1', 'value2')
AllowedValues *AllowedValues `ddl:"keyword" sql:"ALLOWED_VALUES"`
type AllowedValues struct {
    Values []AllowedValue `ddl:"list,comma"`
}
type AllowedValue struct {
    Value string `ddl:"keyword,single_quotes"`
}

// Generates: SET TAG (tag1 = 'value1', tag2 = 'value2')
SetTags []TagAssociation `ddl:"keyword" sql:"SET TAG"`

// Generates: MODIFY COLUMN "column_name" for column operations
column *string `ddl:"parameter,no_equals,double_quotes" sql:"MODIFY COLUMN"`
```

**Operation Types**
- `CreateOperation()` - CREATE commands
- `AlterOperation()` - ALTER commands
- `DropOperation()` - DROP commands
- `ShowOperation()` - SHOW commands
- `ShowByIdOperationWithFiltering()` - ShowByID with filtering options
- `ShowByIdOperationWithNoFiltering()` - ShowByID without filtering
- `DescribeOperation()` - DESCRIBE commands with mapping kind selection
- `CustomOperation()` - Non-standard commands

**DescriptionMappingKind Selection:**
The `DescribeOperation()` requires a `DescriptionMappingKind` parameter that determines the return type and implementation:

- **`DescriptionMappingKindSingleValue`**: Returns a single object (`*ObjectDetails`)
  - **Use when**: DESCRIBE returns object metadata as a single record (name, owner, comment, etc.)
  - **Generated method**: `Describe(ctx context.Context, id Identifier) (*ObjectDetails, error)`
  - **Implementation**: Uses `validateAndQueryOne()` and `result.convert()`
  - **Examples**: Tasks, Streams, Services, Git Repositories, Secrets

- **`DescriptionMappingKindSlice`**: Returns a slice of objects (`[]ObjectProperty`)
  - **Use when**: DESCRIBE returns property-value pairs or multiple configuration entries
  - **Generated method**: `Describe(ctx context.Context, id Identifier) ([]ObjectProperty, error)`
  - **Implementation**: Uses `validateAndQuery()` and `convertRows()`
  - **Examples**: Procedures, Functions, Views, Storage Integrations, Network Policies

**Pattern Recognition:**
- **Single Value**: Object has fixed metadata structure (created_on, name, owner, comment, specific config fields)
- **Slice**: Object has variable properties returned as key-value pairs (property, value, description columns)

### ShowByID Operation

The `ShowByID` operation provides a convenient method to retrieve a single object by its identifier. It internally uses the `Show` operation with appropriate filtering to find the specific object.

**Purpose and Implementation:**
- **Generated methods**: `ShowByID(ctx context.Context, id Identifier) (*Object, error)` and `ShowByIDSafely(ctx context.Context, id Identifier) (*Object, error)`
- **Implementation**: Calls `Show()` with filtering parameters, then uses `collections.FindFirst()` to locate the object by name
- **Safety**: `ShowByIDSafely()` handles cases where the object might not exist without throwing errors

**Filtering Strategy Selection:**
The filtering options for `ShowByID` must match the filtering capabilities available in the corresponding `Show` operation. Choose based on what the Snowflake `SHOW` command supports:

**Available Filtering Types:**
- **`ShowByIDLikeFiltering`**: Uses `LIKE` pattern matching with object name
  - **Generated filter**: `WithLike(Like{Pattern: String(id.Name())})`
  - **Use when**: `SHOW` command supports `LIKE` clause
  - **Universal**: Works for all object types that support pattern matching

- **`ShowByIDInFiltering`**: Uses `IN` clause to filter by parent container
  - **Generated filter**: `WithIn(In{Schema: id.SchemaId()})` (for schema objects)
  - **Use when**: `SHOW` command supports `IN` clause and object has hierarchical structure
  - **Examples**: Schema-level objects can be filtered `IN SCHEMA`

- **`ShowByIDExtendedInFiltering`**: Uses `ExtendedIn` for more complex hierarchical filtering
  - **Generated filter**: `WithIn(ExtendedIn{In: In{Schema: id.SchemaId()}})`
  - **Use when**: `SHOW` command supports extended `IN` syntax
  - **Examples**: Objects that can be filtered by database, schema, or other containers

- **`ShowByIDServiceInFiltering`**: Specialized filtering for service-related objects
  - **Generated filter**: `WithIn(ServiceIn{In: In{Schema: id.SchemaId()}})`
  - **Use when**: Object is service-related and supports service-specific filtering

- **`ShowByIDApplicationNameFiltering`**: Specialized filtering for application objects
  - **Generated filter**: `WithApplicationName(id.DatabaseId())`
  - **Use when**: Object is application-related and uses application name filtering

**Filtering Selection Guidelines:**

**Ideal Combination (Most Common):**
```go
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,           // Primary: Name pattern matching
    g.ShowByIDExtendedInFiltering,     // Secondary: Hierarchical filtering
)
```

**Selection Rules:**
1. **Always include `ShowByIDLikeFiltering`** if the `SHOW` command supports `LIKE`
2. **Add hierarchical filtering** based on object level:
   - **Schema objects**: Add `ShowByIDInFiltering` or `ShowByIDExtendedInFiltering`
   - **Database objects**: Add `ShowByIDInFiltering` if supported
   - **Account objects**: Usually only `ShowByIDLikeFiltering`
3. **Use specialized filtering** for specific object types (services, applications)
4. **No filtering** only when `SHOW` command has no filtering options

**Examples by Object Hierarchy:**

**Account-Level Objects** (Users, Roles, Integrations):
```go
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,  // Only LIKE filtering available
)
```

**Database-Level Objects** (Schemas, Tables):
```go
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,     // Name pattern matching
    g.ShowByIDInFiltering,       // Filter by database
)
```

**Schema-Level Objects** (Views, Functions, Procedures):
```go
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,        // Name pattern matching
    g.ShowByIDExtendedInFiltering,  // Filter by schema/database
)
```

**Service Objects**:
```go
ShowByIdOperationWithFiltering(
    g.ShowByIDLikeFiltering,        // Name pattern matching
    g.ShowByIDServiceInFiltering,   // Service-specific filtering
)
```

**No Filtering Required**:
```go
ShowByIdOperationWithNoFiltering()  // When SHOW has no filtering options
```

**Documentation-Driven Selection:**
Base filtering choices on the Snowflake documentation for the `SHOW` command:
- **Check "Syntax" section** for available clauses (`LIKE`, `IN`, `STARTS WITH`)
- **Match filtering options** to what's documented in Snowflake
- **Test combinations** that make sense for the object hierarchy
- **Prefer LIKE + IN combination** when both are available for optimal performance

**Data Structure Fields and Output Mapping**

**Structure Definition Pattern:**
- **Define output structures separately** above the main interface definition
- **Use descriptive variable names**: `objectDbRow`, `object`, `describeObjectDbRow`, `objectDetails`
- **Follow consistent naming**: `<object>DbRow` for database mapping, `<object>` for plain struct, `describe<Object>DbRow` and `<object>Details` for describe operations
- **Reference structures by variable name** in operations, not inline definitions

**Show/Describe Operations:**
- **NEVER assume fields**: Do not guess or assume what fields SHOW, DESCRIBE, or other operations return
- **VERIFY documentation links first**: Always check that documentation URLs are correct and accessible
- **Use documented OUTPUT sections**: When Snowflake documentation includes OUTPUT sections with field specifications, implement those fields exactly as documented
- **ASK FOR HELP with broken links**: If documentation links are broken or OUTPUT sections are missing, ask for clarification before proceeding
- **Use TODO only for completely unknown structures**:
  ```go
  // TODO: Fields for SHOW OBJECTS output are not documented and no standard pattern applies.
  // Developer should examine actual SHOW OBJECTS output and fill in the correct fields.
  var objectDbRow = g.DbStruct("objectDBRow")
  ```
- **Documentation requirement**: Add fields when OUTPUT sections are explicitly documented in Snowflake documentation
- **Field accuracy**: Match field names, types, and descriptions exactly as specified in OUTPUT documentation
- **Comment Policy**: Only add TODO comments when genuinely unsure about field mappings or when documentation is incomplete. If you've verified the documentation and are confident about the fields, don't add comments - developers will validate the mapping during implementation anyway

**Identifier Type Selection:**
Choose the appropriate identifier type based on Snowflake object hierarchy (see [Object Hierarchies](sdk-development.mdc#object-hierarchies) for complete reference):
- `AccountObjectIdentifier` - Account-level objects
- `DatabaseObjectIdentifier` - Database-level objects
- `SchemaObjectIdentifier` - Schema-level objects
- `SchemaObjectIdentifierWithArguments` - Functions and procedures with arguments

**Privilege and Permission Considerations:**
When implementing new objects, document privilege requirements:
- Research required privileges for each operation (CREATE, ALTER, DROP, SHOW)
- Document role requirements in comments
- Consider edge cases like ownership transfer, grants, and access patterns
- Reference Snowflake documentation for privilege requirements

## Generator Workflow

### 1. Setup
If missing, create definition files and add it to the mapping in `pkg/sdk/poc/main.go`:
```go
"your_object_def.go": sdk.YourObjectDef,
```

### 2. Documentation Analysis
**Critical Phase - Must Be Thorough:**
- Request documentation URLs for ALL operations (CREATE, ALTER, DROP, SHOW, DESCRIBE)
- **VERIFY ALL DOCUMENTATION LINKS** - Check that URLs are accessible and contain the expected content
- **ASK FOR CLARIFICATION** if any documentation links are broken, missing, or incomplete
- Examine EXACT syntax from "Syntax" sections only
- Examine EXACT output fields from "Output" sections when available
- Note ALL optional vs required parameters
- **Analyze SHOW command filtering options** for ShowByID operation:
  - Check for `LIKE` clause support
  - Check for `IN` clause support (database, schema, application)
  - Check for `STARTS WITH` or other filtering options
  - Note object hierarchy level for appropriate filtering selection
- Identify privilege requirements and edge cases
- Document any unclear or ambiguous syntax patterns
- **NEVER make up fields or syntax** - always verify against actual documentation
- **Consult with developers** for unknown or complex scenarios to avoid generating unsupported DSL

### 3. Implementation and Verification
**Based on Documentation Analysis:**
- Map each documented syntax element to appropriate DSL pattern
- Reference similar existing objects for complex patterns
- When uncertain about DSL mapping, ask for guidance rather than guessing

### 4. Generation and Validation
```bash
make run-generator-<object_name>  # Uses filename without _def suffix
```

**Post-Generation Validation:**
- Verify generated SQL matches documented Snowflake syntax
- Test unit tests with realistic parameter combinations
- Validate all DDL tags produce expected output

### 5. Generated Files Structure
The generator creates files following the [File Organization Patterns](sdk-development.mdc#file-organization-patterns):
- `*_gen.go` - Interface and option structs with DDL tags
- `*_impl_gen.go` - Implementation methods (SQL execution)
- `*_dto_gen.go` - Request DTOs for builder pattern
- `*_dto_builders_gen.go` - Constructor and builder methods
- `*_validations_gen.go` - Validation functions for all parameters
- `*_gen_test.go` - Unit test templates with TODO placeholders

### 6. Manual Extensions and Testing
**Extension Files:**
- **NEVER** edit generated files directly (unless it's expected by design, e.g. conversions or unit tests)
- Create `<object_name>_ext.go` for custom extensions
- Mark manual changes in generated files with `// manually adjusted`

**Required Manual Work:**
- Fill conversion mappings in the generated `_impl_gen.go` file
- Complete all testing requirements following [Testing Strategy](./sdk-development.mdc#testing-strategy)
- Document privilege requirements and edge cases

## Common Patterns

### Basic Object with CRUD
```go
var ObjectsDef = g.NewInterface("Objects", "Object", g.KindOfT[SchemaObjectIdentifier]()).
    CreateOperation(url, createStruct).
    AlterOperation(url, alterStruct).
    DropOperation(url, dropStruct).
    ShowOperation(url, dbRow, plainStruct, showStruct)
```

### Complex ALTER with SET/UNSET
```go
AlterOperation(url,
    g.NewQueryStruct("AlterObject").
        Alter().SQL("OBJECT").Name().
        OptionalQueryStructField("Set",
            g.NewQueryStruct("ObjectSet").
                OptionalComment().
                OptionalTextAssignment("FIELD", options),
            g.KeywordOptions().SQL("SET"),
        ).
        OptionalQueryStructField("Unset",
            g.NewQueryStruct("ObjectUnset").
                OptionalSQL("COMMENT").
                OptionalSQL("FIELD"),
            g.ListOptions().NoParentheses().SQL("UNSET"),
        ),
)
```

## Testing After Generation

**Generated Test Files:**
The generator creates `*_gen_test.go` files with unit test templates containing TODO placeholders.

**Manual Completion Required:**
All generated tests must be completed manually following the comprehensive [Testing Strategy](./sdk-development.mdc#testing-strategy) in SDK Development Rules.

**Key Post-Generation Tasks:**
- **Complete unit test TODOs** with realistic SQL expectations
- **Implement integration tests** in `testint/` directory
- **Test all CRUD operations** against real Snowflake instances
- **Document and test privilege requirements**
- **Verify SQL output** matches Snowflake documentation exactly

## Documentation and Privilege Requirements

**When implementing new objects, always document:**

**Privilege Requirements:**
```go
// CREATE OBJECT requires:
// - CREATE privileges on the schema
// - USAGE privileges on the database and schema
// - Additional privileges: [list specific requirements from Snowflake docs]

// ALTER OBJECT requires:
// - Object ownership OR ALTER privileges
// - [specific privilege requirements]

// DROP OBJECT requires:
// - Object ownership OR DROP privileges
```

**Edge Cases and Limitations:**
```go
// Known limitations:
// - Feature X requires Snowflake version Y or higher
// - Operation Z requires specific account settings
// - Privilege P may require account admin role in certain configurations
```

## Best Practices

**Documentation-Driven Development:**
- **Always start with official Snowflake documentation**
- **Map syntax exactly** - do not add unsupported features
- **Document privilege requirements** from Snowflake docs
- **Consult developers** for ambiguous or complex syntax patterns

**Generator-Specific Quality:**
- **Complete all generated TODO comments** with realistic tests
- **Validate SQL output** against Snowflake documentation exactly
- **Test comprehensive parameter combinations** in unit tests
- **Verify DDL tag combinations** produce expected SQL patterns
- **Use appropriate identifier types** for object hierarchy
- **Follow architecture patterns** from [SDK Development Rules](sdk-development.mdc)
