// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"context"

	"github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/internal/collections"
)

var _ HybridTables = (*hybridTables)(nil)

var (
	_ convertibleRow[HybridTable]        = new(hybridTableRow)
	_ convertibleRow[HybridTableDetails] = new(hybridTableDetailsRow)
)

type hybridTables struct {
	client *Client
}

func (v *hybridTables) Create(ctx context.Context, request *CreateHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) Alter(ctx context.Context, request *AlterHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) Drop(ctx context.Context, request *DropHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) DropSafely(ctx context.Context, id SchemaObjectIdentifier) error {
	return SafeDrop(v.client, func() error { return v.Drop(ctx, NewDropHybridTableRequest(id).WithIfExists(true)) }, ctx, id)
}

func (v *hybridTables) Show(ctx context.Context, request *ShowHybridTableRequest) ([]HybridTable, error) {
	opts := request.toOpts()
	dbRows, err := validateAndQuery[hybridTableRow](v.client, ctx, opts)
	if err != nil {
		return nil, err
	}
	return convertRows[hybridTableRow, HybridTable](dbRows)
}

func (v *hybridTables) ShowByID(ctx context.Context, id SchemaObjectIdentifier) (*HybridTable, error) {
	request := NewShowHybridTableRequest().
		WithLike(Like{Pattern: String(id.Name())}).
		WithIn(In{Schema: id.SchemaId()})
	hybridTables, err := v.Show(ctx, request)
	if err != nil {
		return nil, err
	}
	return collections.FindFirst(hybridTables, func(r HybridTable) bool { return r.Name == id.Name() })
}

func (v *hybridTables) ShowByIDSafely(ctx context.Context, id SchemaObjectIdentifier) (*HybridTable, error) {
	return SafeShowById(v.client, v.ShowByID, ctx, id)
}

func (v *hybridTables) Describe(ctx context.Context, id SchemaObjectIdentifier) ([]HybridTableDetails, error) {
	opts := &DescribeHybridTableOptions{
		name: id,
	}
	rows, err := validateAndQuery[hybridTableDetailsRow](v.client, ctx, opts)
	if err != nil {
		return nil, err
	}
	return convertRows[hybridTableDetailsRow, HybridTableDetails](rows)
}

func (r *CreateHybridTableRequest) toOpts() *CreateHybridTableOptions {
	opts := &CreateHybridTableOptions{
		OrReplace:   r.OrReplace,
		IfNotExists: r.IfNotExists,
		name:        r.name,
		Comment:     r.Comment,
	}
	opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
	if r.ColumnsAndConstraints.Columns != nil {
		s := make([]HybridTableColumn, len(r.ColumnsAndConstraints.Columns))
		for i, v := range r.ColumnsAndConstraints.Columns {
			s[i] = HybridTableColumn{
				Name:             v.Name,
				Type:             v.Type,
				InlineConstraint: v.InlineConstraint,
				NotNull:          v.NotNull,
				DefaultValue:     v.DefaultValue,
				Collate:          v.Collate,
				Comment:          v.Comment,
			}
		}
		opts.ColumnsAndConstraints.Columns = s
	}
	if r.ColumnsAndConstraints.OutOfLineConstraint != nil {
		s := make([]HybridTableOutOfLineConstraint, len(r.ColumnsAndConstraints.OutOfLineConstraint))
		for i, v := range r.ColumnsAndConstraints.OutOfLineConstraint {
			s[i] = HybridTableOutOfLineConstraint{
				Name:               v.Name,
				Type:               v.Type,
				Columns:            v.Columns,
				ForeignKey:         v.ForeignKey,
				Enforced:           v.Enforced,
				NotEnforced:        v.NotEnforced,
				Deferrable:         v.Deferrable,
				NotDeferrable:      v.NotDeferrable,
				InitiallyDeferred:  v.InitiallyDeferred,
				InitiallyImmediate: v.InitiallyImmediate,
				Enable:             v.Enable,
				Disable:            v.Disable,
				Validate:           v.Validate,
				Novalidate:         v.Novalidate,
				Rely:               v.Rely,
				Norely:             v.Norely,
			}
		}
		opts.ColumnsAndConstraints.OutOfLineConstraint = s
	}
	if r.ColumnsAndConstraints.OutOfLineIndex != nil {
		s := make([]HybridTableOutOfLineIndex, len(r.ColumnsAndConstraints.OutOfLineIndex))
		for i, v := range r.ColumnsAndConstraints.OutOfLineIndex {
			s[i] = HybridTableOutOfLineIndex{
				Name:           v.Name,
				Columns:        v.Columns,
				IncludeColumns: v.IncludeColumns,
			}
		}
		opts.ColumnsAndConstraints.OutOfLineIndex = s
	}
	return opts
}

func (r *AlterHybridTableRequest) toOpts() *AlterHybridTableOptions {
	opts := &AlterHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
		NewName:  r.NewName,
	}
	if r.AddColumnAction != nil {
		opts.AddColumnAction = &HybridTableAddColumnAction{
			IfNotExists:      r.AddColumnAction.IfNotExists,
			Name:             r.AddColumnAction.Name,
			Type:             r.AddColumnAction.Type,
			Collate:          r.AddColumnAction.Collate,
			DefaultValue:     r.AddColumnAction.DefaultValue,
			InlineConstraint: r.AddColumnAction.InlineConstraint,
			Comment:          r.AddColumnAction.Comment,
		}
	}
	if r.ConstraintAction != nil {
		opts.ConstraintAction = &HybridTableConstraintAction{}
		if r.ConstraintAction.Add != nil {
			opts.ConstraintAction.Add = &HybridTableConstraintActionAdd{}
			opts.ConstraintAction.Add.OutOfLineConstraint = HybridTableOutOfLineConstraint{
				Name:               r.ConstraintAction.Add.OutOfLineConstraint.Name,
				Type:               r.ConstraintAction.Add.OutOfLineConstraint.Type,
				Columns:            r.ConstraintAction.Add.OutOfLineConstraint.Columns,
				ForeignKey:         r.ConstraintAction.Add.OutOfLineConstraint.ForeignKey,
				Enforced:           r.ConstraintAction.Add.OutOfLineConstraint.Enforced,
				NotEnforced:        r.ConstraintAction.Add.OutOfLineConstraint.NotEnforced,
				Deferrable:         r.ConstraintAction.Add.OutOfLineConstraint.Deferrable,
				NotDeferrable:      r.ConstraintAction.Add.OutOfLineConstraint.NotDeferrable,
				InitiallyDeferred:  r.ConstraintAction.Add.OutOfLineConstraint.InitiallyDeferred,
				InitiallyImmediate: r.ConstraintAction.Add.OutOfLineConstraint.InitiallyImmediate,
				Enable:             r.ConstraintAction.Add.OutOfLineConstraint.Enable,
				Disable:            r.ConstraintAction.Add.OutOfLineConstraint.Disable,
				Validate:           r.ConstraintAction.Add.OutOfLineConstraint.Validate,
				Novalidate:         r.ConstraintAction.Add.OutOfLineConstraint.Novalidate,
				Rely:               r.ConstraintAction.Add.OutOfLineConstraint.Rely,
				Norely:             r.ConstraintAction.Add.OutOfLineConstraint.Norely,
			}
		}
		if r.ConstraintAction.Rename != nil {
			opts.ConstraintAction.Rename = &HybridTableConstraintActionRename{
				OldName: r.ConstraintAction.Rename.OldName,
				NewName: r.ConstraintAction.Rename.NewName,
			}
		}
		if r.ConstraintAction.Drop != nil {
			opts.ConstraintAction.Drop = &HybridTableConstraintActionDrop{
				ConstraintName: r.ConstraintAction.Drop.ConstraintName,
				PrimaryKey:     r.ConstraintAction.Drop.PrimaryKey,
				Unique:         r.ConstraintAction.Drop.Unique,
				ForeignKey:     r.ConstraintAction.Drop.ForeignKey,
				Columns:        r.ConstraintAction.Drop.Columns,
				Cascade:        r.ConstraintAction.Drop.Cascade,
				Restrict:       r.ConstraintAction.Drop.Restrict,
			}
		}
	}
	if r.AlterColumnAction != nil {
		s := make([]HybridTableAlterColumnAction, len(r.AlterColumnAction))
		for i, v := range r.AlterColumnAction {
			s[i] = HybridTableAlterColumnAction{
				ColumnName:   v.ColumnName,
				DropDefault:  v.DropDefault,
				SetDefault:   v.SetDefault,
				Type:         v.Type,
				Comment:      v.Comment,
				UnsetComment: v.UnsetComment,
			}
			if v.NotNullConstraint != nil {
				s[i].NotNullConstraint = &HybridTableColumnNotNullConstraint{
					SetNotNull:  v.NotNullConstraint.SetNotNull,
					DropNotNull: v.NotNullConstraint.DropNotNull,
				}
			}
		}
		opts.AlterColumnAction = s
	}
	if r.DropColumnAction != nil {
		opts.DropColumnAction = &HybridTableDropColumnAction{
			IfExists: r.DropColumnAction.IfExists,
			Columns:  r.DropColumnAction.Columns,
		}
	}
	if r.DropIndexAction != nil {
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IfExists:  r.DropIndexAction.IfExists,
			IndexName: r.DropIndexAction.IndexName,
		}
	}
	if r.ClusteringAction != nil {
		opts.ClusteringAction = &HybridTableClusteringAction{
			ClusterBy:         r.ClusteringAction.ClusterBy,
			DropClusteringKey: r.ClusteringAction.DropClusteringKey,
		}
		if r.ClusteringAction.Recluster != nil {
			opts.ClusteringAction.Recluster = &HybridTableReclusterAction{
				MaxSize: r.ClusteringAction.Recluster.MaxSize,
				Where:   r.ClusteringAction.Recluster.Where,
			}
		}
		if r.ClusteringAction.ChangeReclusterState != nil {
			opts.ClusteringAction.ChangeReclusterState = &HybridTableReclusterChangeState{
				State: r.ClusteringAction.ChangeReclusterState.State,
			}
		}
	}
	if r.Set != nil {
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays:    r.Set.DataRetentionTimeInDays,
			MaxDataExtensionTimeInDays: r.Set.MaxDataExtensionTimeInDays,
			ChangeTracking:             r.Set.ChangeTracking,
			DefaultDdlCollation:        r.Set.DefaultDdlCollation,
			EnableSchemaEvolution:      r.Set.EnableSchemaEvolution,
			Contact:                    r.Set.Contact,
			Comment:                    r.Set.Comment,
			RowTimestamp:               r.Set.RowTimestamp,
		}
	}
	if r.Unset != nil {
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays:    r.Unset.DataRetentionTimeInDays,
			MaxDataExtensionTimeInDays: r.Unset.MaxDataExtensionTimeInDays,
			ChangeTracking:             r.Unset.ChangeTracking,
			DefaultDdlCollation:        r.Unset.DefaultDdlCollation,
			EnableSchemaEvolution:      r.Unset.EnableSchemaEvolution,
			ContactPurpose:             r.Unset.ContactPurpose,
			Comment:                    r.Unset.Comment,
		}
	}
	return opts
}

func (r *DropHybridTableRequest) toOpts() *DropHybridTableOptions {
	opts := &DropHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
		Cascade:  r.Cascade,
		Restrict: r.Restrict,
	}
	return opts
}

func (r *ShowHybridTableRequest) toOpts() *ShowHybridTableOptions {
	opts := &ShowHybridTableOptions{
		Terse:      r.Terse,
		Like:       r.Like,
		In:         r.In,
		StartsWith: r.StartsWith,
		Limit:      r.Limit,
	}
	return opts
}

func (r *DescribeHybridTableRequest) toOpts() *DescribeHybridTableOptions {
	opts := &DescribeHybridTableOptions{
		name: r.name,
	}
	return opts
}

func (r *CreateIndexHybridTableRequest) toOpts() *CreateIndexHybridTableOptions {
	opts := &CreateIndexHybridTableOptions{
		OrReplace:      r.OrReplace,
		IfNotExists:    r.IfNotExists,
		name:           r.name,
		TableName:      r.TableName,
		Columns:        r.Columns,
		IncludeColumns: r.IncludeColumns,
	}
	return opts
}

func (r *DropIndexHybridTableRequest) toOpts() *DropIndexHybridTableOptions {
	opts := &DropIndexHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
	}
	return opts
}

func (r *ShowIndexesHybridTableRequest) toOpts() *ShowIndexesHybridTableOptions {
	opts := &ShowIndexesHybridTableOptions{
		Like:       r.Like,
		In:         r.In,
		StartsWith: r.StartsWith,
		Limit:      r.Limit,
	}
	return opts
}
