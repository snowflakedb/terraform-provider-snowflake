// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"context"

	"github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/internal/collections"
)

var _ HybridTables = (*hybridTables)(nil)

var (
	_ convertibleRow[HybridTable]        = new(hybridTableRow)
	_ convertibleRow[HybridTableDetails] = new(hybridTableDetailsRow)
)

type hybridTables struct {
	client *Client
}

func (v *hybridTables) Create(ctx context.Context, request *CreateHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) Alter(ctx context.Context, request *AlterHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) Drop(ctx context.Context, request *DropHybridTableRequest) error {
	opts := request.toOpts()
	return validateAndExec(v.client, ctx, opts)
}

func (v *hybridTables) DropSafely(ctx context.Context, id SchemaObjectIdentifier) error {
	return SafeDrop(v.client, func() error { return v.Drop(ctx, NewDropHybridTableRequest(id).WithIfExists(true)) }, ctx, id)
}

func (v *hybridTables) Show(ctx context.Context, request *ShowHybridTableRequest) ([]HybridTable, error) {
	opts := request.toOpts()
	dbRows, err := validateAndQuery[hybridTableRow](v.client, ctx, opts)
	if err != nil {
		return nil, err
	}
	return convertRows[hybridTableRow, HybridTable](dbRows)
}

func (v *hybridTables) ShowByID(ctx context.Context, id SchemaObjectIdentifier) (*HybridTable, error) {
	request := NewShowHybridTableRequest().
		WithLike(Like{Pattern: String(id.Name())}).
		WithIn(In{Schema: id.SchemaId()})
	hybridTables, err := v.Show(ctx, request)
	if err != nil {
		return nil, err
	}
	return collections.FindFirst(hybridTables, func(r HybridTable) bool { return r.Name == id.Name() })
}

func (v *hybridTables) ShowByIDSafely(ctx context.Context, id SchemaObjectIdentifier) (*HybridTable, error) {
	return SafeShowById(v.client, v.ShowByID, ctx, id)
}

func (v *hybridTables) Describe(ctx context.Context, id SchemaObjectIdentifier) ([]HybridTableDetails, error) {
	opts := &DescribeHybridTableOptions{
		name: id,
	}
	rows, err := validateAndQuery[hybridTableDetailsRow](v.client, ctx, opts)
	if err != nil {
		return nil, err
	}
	return convertRows[hybridTableDetailsRow, HybridTableDetails](rows)
}

func (r *CreateHybridTableRequest) toOpts() *CreateHybridTableOptions {
	opts := &CreateHybridTableOptions{
		OrReplace:             r.OrReplace,
		IfNotExists:           r.IfNotExists,
		name:                  r.name,
		ColumnsAndConstraints: r.ColumnsAndConstraints,
		Comment:               r.Comment,
	}
	return opts
}

func (r *AlterHybridTableRequest) toOpts() *AlterHybridTableOptions {
	opts := &AlterHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
		NewName:  r.NewName,
	}
	if r.AddColumnAction != nil {
		opts.AddColumnAction = &HybridTableAddColumnAction{
			IfNotExists:      r.AddColumnAction.IfNotExists,
			Name:             r.AddColumnAction.Name,
			Type:             r.AddColumnAction.Type,
			Collate:          r.AddColumnAction.Collate,
			DefaultValue:     r.AddColumnAction.DefaultValue,
			InlineConstraint: r.AddColumnAction.InlineConstraint,
			Comment:          r.AddColumnAction.Comment,
		}
	}
	if r.ConstraintAction != nil {
		opts.ConstraintAction = &HybridTableConstraintAction{}
		if r.ConstraintAction.Add != nil {
			opts.ConstraintAction.Add = &HybridTableConstraintActionAdd{
				OutOfLineConstraint: r.ConstraintAction.Add.OutOfLineConstraint,
			}
		}
		if r.ConstraintAction.Rename != nil {
			opts.ConstraintAction.Rename = &HybridTableConstraintActionRename{
				OldName: r.ConstraintAction.Rename.OldName,
				NewName: r.ConstraintAction.Rename.NewName,
			}
		}
		if r.ConstraintAction.Drop != nil {
			opts.ConstraintAction.Drop = &HybridTableConstraintActionDrop{
				ConstraintName: r.ConstraintAction.Drop.ConstraintName,
				PrimaryKey:     r.ConstraintAction.Drop.PrimaryKey,
				Unique:         r.ConstraintAction.Drop.Unique,
				ForeignKey:     r.ConstraintAction.Drop.ForeignKey,
				Columns:        r.ConstraintAction.Drop.Columns,
				Cascade:        r.ConstraintAction.Drop.Cascade,
				Restrict:       r.ConstraintAction.Drop.Restrict,
			}
		}
	}
	if r.AlterColumnAction != nil {
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName:   r.AlterColumnAction.ColumnName,
			DropDefault:  r.AlterColumnAction.DropDefault,
			SetDefault:   r.AlterColumnAction.SetDefault,
			Type:         r.AlterColumnAction.Type,
			Comment:      r.AlterColumnAction.Comment,
			UnsetComment: r.AlterColumnAction.UnsetComment,
		}
		if r.AlterColumnAction.NotNullConstraint != nil {
			opts.AlterColumnAction.NotNullConstraint = &HybridTableColumnNotNullConstraint{
				SetNotNull:  r.AlterColumnAction.NotNullConstraint.SetNotNull,
				DropNotNull: r.AlterColumnAction.NotNullConstraint.DropNotNull,
			}
		}
	}
	if r.DropColumnAction != nil {
		opts.DropColumnAction = &HybridTableDropColumnAction{
			IfExists: r.DropColumnAction.IfExists,
			Columns:  r.DropColumnAction.Columns,
		}
	}
	if r.DropIndexAction != nil {
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IfExists:  r.DropIndexAction.IfExists,
			IndexName: r.DropIndexAction.IndexName,
		}
	}
	if r.ClusteringAction != nil {
		opts.ClusteringAction = &HybridTableClusteringAction{
			ClusterBy:         r.ClusteringAction.ClusterBy,
			DropClusteringKey: r.ClusteringAction.DropClusteringKey,
		}
		if r.ClusteringAction.Recluster != nil {
			opts.ClusteringAction.Recluster = &HybridTableReclusterAction{
				MaxSize: r.ClusteringAction.Recluster.MaxSize,
				Where:   r.ClusteringAction.Recluster.Where,
			}
		}
		if r.ClusteringAction.ChangeReclusterState != nil {
			opts.ClusteringAction.ChangeReclusterState = &HybridTableReclusterChangeState{
				State: r.ClusteringAction.ChangeReclusterState.State,
			}
		}
	}
	if r.Set != nil {
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays:    r.Set.DataRetentionTimeInDays,
			MaxDataExtensionTimeInDays: r.Set.MaxDataExtensionTimeInDays,
			ChangeTracking:             r.Set.ChangeTracking,
			DefaultDdlCollation:        r.Set.DefaultDdlCollation,
			EnableSchemaEvolution:      r.Set.EnableSchemaEvolution,
			Contact:                    r.Set.Contact,
			Comment:                    r.Set.Comment,
			RowTimestamp:               r.Set.RowTimestamp,
		}
	}
	if r.Unset != nil {
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays:    r.Unset.DataRetentionTimeInDays,
			MaxDataExtensionTimeInDays: r.Unset.MaxDataExtensionTimeInDays,
			ChangeTracking:             r.Unset.ChangeTracking,
			DefaultDdlCollation:        r.Unset.DefaultDdlCollation,
			EnableSchemaEvolution:      r.Unset.EnableSchemaEvolution,
			ContactPurpose:             r.Unset.ContactPurpose,
			Comment:                    r.Unset.Comment,
		}
	}
	return opts
}

func (r *DropHybridTableRequest) toOpts() *DropHybridTableOptions {
	opts := &DropHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
		Cascade:  r.Cascade,
		Restrict: r.Restrict,
	}
	return opts
}

func (r *ShowHybridTableRequest) toOpts() *ShowHybridTableOptions {
	opts := &ShowHybridTableOptions{
		Terse:      r.Terse,
		Like:       r.Like,
		In:         r.In,
		StartsWith: r.StartsWith,
		Limit:      r.Limit,
	}
	return opts
}

func (r *DescribeHybridTableRequest) toOpts() *DescribeHybridTableOptions {
	opts := &DescribeHybridTableOptions{
		name: r.name,
	}
	return opts
}

func (r *CreateIndexHybridTableRequest) toOpts() *CreateIndexHybridTableOptions {
	opts := &CreateIndexHybridTableOptions{
		OrReplace:      r.OrReplace,
		IfNotExists:    r.IfNotExists,
		name:           r.name,
		TableName:      r.TableName,
		Columns:        r.Columns,
		IncludeColumns: r.IncludeColumns,
	}
	return opts
}

func (r *DropIndexHybridTableRequest) toOpts() *DropIndexHybridTableOptions {
	opts := &DropIndexHybridTableOptions{
		IfExists: r.IfExists,
		name:     r.name,
	}
	return opts
}

func (r *ShowIndexesHybridTableRequest) toOpts() *ShowIndexesHybridTableOptions {
	opts := &ShowIndexesHybridTableOptions{}
	if r.In != nil {
		opts.In = &ShowHybridTableIndexIn{
			Table: &r.In.Table,
		}
	}
	return opts
}
