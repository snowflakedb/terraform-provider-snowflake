// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestStages_CreateInternal(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateInternalStageOptions
	defaultOpts := func() *CreateInternalStageOptions {
		return &CreateInternalStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateInternalStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateInternalStageOptions", "OrReplace", "IfNotExists"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.Encryption.SnowflakeFull opts.Encryption.SnowflakeSse] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.Encryption = &InternalStageEncryption{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.Encryption", "SnowflakeFull", "SnowflakeSse"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE STAGE %s", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Temporary = Bool(true)
		opts.IfNotExists = Bool(true)
		opts.Encryption = &InternalStageEncryption{
			SnowflakeFull: &InternalStageEncryptionSnowflakeFull{},
		}
		opts.DirectoryTableOptions = &InternalDirectoryTableOptions{
			Enable:      true,
			AutoRefresh: Bool(true),
		}
		opts.FileFormat = &StageFileFormat{
			FormatName: String("format name"),
		}
		opts.Comment = String("some comment")
		opts.Tag = []TagAssociation{
			{
				Name:  NewAccountObjectIdentifier("tag-name"),
				Value: "tag-value",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE TEMPORARY STAGE IF NOT EXISTS %s ENCRYPTION = (TYPE = 'SNOWFLAKE_FULL') DIRECTORY = (ENABLE = true AUTO_REFRESH = true) FILE_FORMAT = (FORMAT_NAME = 'format name') COMMENT = 'some comment' TAG ("tag-name" = 'tag-value')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: SnowflakeSse", func(t *testing.T) {
		opts := defaultOpts()
		opts.Encryption = &InternalStageEncryption{
			SnowflakeSse: &InternalStageEncryptionSnowflakeSse{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s ENCRYPTION = (TYPE = 'SNOWFLAKE_SSE')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = CSV)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: CSV complete", func(t *testing.T) {
		opts := defaultOpts()
		compression := StageFileFormatCsvCompressionGzip
		binaryFormat := StageFileFormatBinaryFormatHex
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				Compression:                &compression,
				RecordDelimiter:            &StageFileFormatStringOrNone{Value: String("\n")},
				FieldDelimiter:             &StageFileFormatStringOrNone{Value: String(",")},
				MultiLine:                  Bool(true),
				FileExtension:              &StageFileFormatStringOrNone{Value: String(".csv")},
				ParseHeader:                Bool(true),
				SkipHeader:                 Int(1),
				SkipBlankLines:             Bool(true),
				DateFormat:                 &StageFileFormatStringOrAuto{Value: String("YYYY-MM-DD")},
				TimeFormat:                 &StageFileFormatStringOrAuto{Value: String("HH24:MI:SS")},
				TimestampFormat:            &StageFileFormatStringOrAuto{Value: String("YYYY-MM-DD HH24:MI:SS")},
				BinaryFormat:               &binaryFormat,
				Escape:                     &StageFileFormatStringOrNone{Value: String("\\")},
				EscapeUnenclosedField:      &StageFileFormatStringOrNone{Value: String("\\")},
				TrimSpace:                  Bool(true),
				FieldOptionallyEnclosedBy:  &StageFileFormatStringOrNone{Value: String("\"")},
				NullIf:                     []NullString{{S: "NULL"}, {S: ""}},
				ErrorOnColumnCountMismatch: Bool(true),
				ReplaceInvalidCharacters:   Bool(true),
				EmptyFieldAsNull:           Bool(true),
				SkipByteOrderMark:          Bool(true),
				Encoding:                   String("UTF8"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = CSV COMPRESSION = GZIP RECORD_DELIMITER = Value = '\n' FIELD_DELIMITER = Value = ',' MULTI_LINE = true FILE_EXTENSION = Value = '.csv' PARSE_HEADER = true SKIP_HEADER = 1 SKIP_BLANK_LINES = true DATE_FORMAT = Value = 'YYYY-MM-DD' TIME_FORMAT = Value = 'HH24:MI:SS' TIMESTAMP_FORMAT = Value = 'YYYY-MM-DD HH24:MI:SS' BINARY_FORMAT = HEX ESCAPE = Value = '\\' ESCAPE_UNENCLOSED_FIELD = Value = '\\' TRIM_SPACE = true FIELD_OPTIONALLY_ENCLOSED_BY = Value = '\"' NULL_IF = ('NULL', '') ERROR_ON_COLUMN_COUNT_MISMATCH = true REPLACE_INVALID_CHARACTERS = true EMPTY_FIELD_AS_NULL = true SKIP_BYTE_ORDER_MARK = true ENCODING = 'UTF8')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: CSV with NONE values", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				RecordDelimiter:       &StageFileFormatStringOrNone{None: Bool(true)},
				FieldDelimiter:        &StageFileFormatStringOrNone{None: Bool(true)},
				FileExtension:         &StageFileFormatStringOrNone{None: Bool(true)},
				Escape:                &StageFileFormatStringOrNone{None: Bool(true)},
				EscapeUnenclosedField: &StageFileFormatStringOrNone{None: Bool(true)},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = CSV RECORD_DELIMITER = NONE FIELD_DELIMITER = NONE FILE_EXTENSION = NONE ESCAPE = NONE ESCAPE_UNENCLOSED_FIELD = NONE)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: CSV with AUTO values", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				DateFormat:      &StageFileFormatStringOrAuto{Auto: Bool(true)},
				TimeFormat:      &StageFileFormatStringOrAuto{Auto: Bool(true)},
				TimestampFormat: &StageFileFormatStringOrAuto{Auto: Bool(true)},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = CSV DATE_FORMAT = AUTO TIME_FORMAT = AUTO TIMESTAMP_FORMAT = AUTO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = JSON)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON complete", func(t *testing.T) {
		opts := defaultOpts()
		compression := StageFileFormatJsonCompressionBrotli
		binaryFormat := StageFileFormatBinaryFormatBase64
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{
				Compression:              &compression,
				DateFormat:               &StageFileFormatStringOrAuto{Value: String("YYYY-MM-DD")},
				TimeFormat:               &StageFileFormatStringOrAuto{Value: String("HH24:MI:SS")},
				TimestampFormat:          &StageFileFormatStringOrAuto{Value: String("YYYY-MM-DD HH24:MI:SS")},
				BinaryFormat:             &binaryFormat,
				TrimSpace:                Bool(true),
				MultiLine:                Bool(true),
				NullIf:                   []NullString{{S: "NULL"}},
				FileExtension:            &StageFileFormatStringOrNone{Value: String(".json")},
				EnableOctal:              Bool(true),
				AllowDuplicate:           Bool(true),
				StripOuterArray:          Bool(true),
				StripNullValues:          Bool(true),
				ReplaceInvalidCharacters: Bool(true),
				IgnoreUtf8Errors:         Bool(true),
				SkipByteOrderMark:        Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = JSON COMPRESSION = BROTLI DATE_FORMAT = Value = 'YYYY-MM-DD' TIME_FORMAT = Value = 'HH24:MI:SS' TIMESTAMP_FORMAT = Value = 'YYYY-MM-DD HH24:MI:SS' BINARY_FORMAT = BASE64 TRIM_SPACE = true MULTI_LINE = true NULL_IF = ('NULL') FILE_EXTENSION = Value = '.json' ENABLE_OCTAL = true ALLOW_DUPLICATE = true STRIP_OUTER_ARRAY = true STRIP_NULL_VALUES = true REPLACE_INVALID_CHARACTERS = true IGNORE_UTF8_ERRORS = true SKIP_BYTE_ORDER_MARK = true)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = AVRO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO complete", func(t *testing.T) {
		opts := defaultOpts()
		compression := StageFileFormatAvroCompressionDeflate
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{
				Compression:              &compression,
				TrimSpace:                Bool(true),
				ReplaceInvalidCharacters: Bool(true),
				NullIf:                   []NullString{{S: "NULL"}},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = AVRO COMPRESSION = DEFLATE TRIM_SPACE = true REPLACE_INVALID_CHARACTERS = true NULL_IF = ('NULL'))`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = ORC)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC complete", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{
				TrimSpace:                Bool(true),
				ReplaceInvalidCharacters: Bool(true),
				NullIf:                   []NullString{{S: "NULL"}, {S: ""}},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = ORC TRIM_SPACE = true REPLACE_INVALID_CHARACTERS = true NULL_IF = ('NULL', ''))`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = PARQUET)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet complete", func(t *testing.T) {
		opts := defaultOpts()
		compression := StageFileFormatParquetCompressionLzo
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{
				Compression:              &compression,
				SnappyCompression:        Bool(true),
				BinaryAsText:             Bool(true),
				UseLogicalType:           Bool(true),
				TrimSpace:                Bool(true),
				UseVectorizedScanner:     Bool(true),
				ReplaceInvalidCharacters: Bool(true),
				NullIf:                   []NullString{{S: "NULL"}},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = PARQUET COMPRESSION = LZO SNAPPY_COMPRESSION = true BINARY_AS_TEXT = true USE_LOGICAL_TYPE = true TRIM_SPACE = true USE_VECTORIZED_SCANNER = true REPLACE_INVALID_CHARACTERS = true NULL_IF = ('NULL'))`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = XML)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML complete", func(t *testing.T) {
		opts := defaultOpts()
		compression := StageFileFormatXmlCompressionZstd
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{
				Compression:              &compression,
				IgnoreUtf8Errors:         Bool(true),
				PreserveSpace:            Bool(true),
				StripOuterElement:        Bool(true),
				DisableAutoConvert:       Bool(true),
				ReplaceInvalidCharacters: Bool(true),
				SkipByteOrderMark:        Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s FILE_FORMAT = (TYPE = XML COMPRESSION = ZSTD IGNORE_UTF8_ERRORS = true PRESERVE_SPACE = true STRIP_OUTER_ELEMENT = true DISABLE_AUTO_CONVERT = true REPLACE_INVALID_CHARACTERS = true SKIP_BYTE_ORDER_MARK = true)`, id.FullyQualifiedName())
	})

	// added manually - file format validation tests
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: CSV RecordDelimiter exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				RecordDelimiter: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.RecordDelimiter", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV RecordDelimiter exactly one of Value/None - both set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				RecordDelimiter: &StageFileFormatStringOrNone{Value: String("\n"), None: Bool(true)},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.RecordDelimiter", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV FieldDelimiter exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				FieldDelimiter: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.FieldDelimiter", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV FileExtension exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				FileExtension: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.FileExtension", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV DateFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				DateFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.DateFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: CSV DateFormat exactly one of Value/Auto - both set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				DateFormat: &StageFileFormatStringOrAuto{Value: String("YYYY-MM-DD"), Auto: Bool(true)},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.DateFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: CSV TimeFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				TimeFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.TimeFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: CSV TimestampFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				TimestampFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.TimestampFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: CSV Escape exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				Escape: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.Escape", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV EscapeUnenclosedField exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				EscapeUnenclosedField: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.EscapeUnenclosedField", "Value", "None"))
	})

	// added manually
	t.Run("validation: CSV FieldOptionallyEnclosedBy exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{
				FieldOptionallyEnclosedBy: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.CsvOptions.FieldOptionallyEnclosedBy", "Value", "None"))
	})

	// added manually
	t.Run("validation: JSON DateFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{
				DateFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.JsonOptions.DateFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: JSON TimeFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{
				TimeFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.JsonOptions.TimeFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: JSON TimestampFormat exactly one of Value/Auto - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{
				TimestampFormat: &StageFileFormatStringOrAuto{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.JsonOptions.TimestampFormat", "Value", "Auto"))
	})

	// added manually
	t.Run("validation: JSON FileExtension exactly one of Value/None - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{
				FileExtension: &StageFileFormatStringOrNone{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateInternalStageOptions.FileFormat.JsonOptions.FileExtension", "Value", "None"))
	})
}

func TestStages_CreateOnS3(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateOnS3StageOptions
	defaultOpts := func() *CreateOnS3StageOptions {
		return &CreateOnS3StageOptions{
			name: id,
			ExternalStageParams: ExternalS3StageParams{
				Url: "s3://example.com",
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateOnS3StageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.Credentials]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalS3StageParams{
			StorageIntegration: &integrationId,
			Credentials: &ExternalStageS3Credentials{
				AwsRole: String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions.ExternalStageParams", "StorageIntegration", "Credentials"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.UsePrivatelinkEndpoint]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalS3StageParams{
			StorageIntegration:     &integrationId,
			UsePrivatelinkEndpoint: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions.ExternalStageParams", "StorageIntegration", "UsePrivatelinkEndpoint"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsKeyId opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsKeyId: String("aws-key-id"),
				AwsRole:  String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions.ExternalStageParams.Credentials", "AwsKeyId", "AwsRole"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsSecretKey opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsSecretKey: String("aws-secret-key"),
				AwsRole:      String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions.ExternalStageParams.Credentials", "AwsSecretKey", "AwsRole"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsToken opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsToken: String("aws-token"),
				AwsRole:  String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3StageOptions.ExternalStageParams.Credentials", "AwsToken", "AwsRole"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageS3Encryption{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnS3StageOptions.ExternalStageParams.Encryption", "AwsCse", "AwsSseS3", "AwsSseKms", "None"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE STAGE %s URL = 's3://example.com'", id.FullyQualifiedName())
	})

	// variants added manually
	t.Run("all options - storage integration", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.Temporary = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalS3StageParams{
			Url:                "some url",
			AwsAccessPointArn:  String("aws-access-point-arn"),
			StorageIntegration: &integrationId,
			Encryption: &ExternalStageS3Encryption{
				AwsCse: &ExternalStageS3EncryptionAwsCse{
					MasterKey: "master-key",
				},
			},
		}
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE TEMPORARY STAGE %s URL = 'some url' AWS_ACCESS_POINT_ARN = 'aws-access-point-arn' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'AWS_CSE' MASTER_KEY = 'master-key') FILE_FORMAT = (TYPE = CSV) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	t.Run("all options - directory table and credentials", func(t *testing.T) {
		opts := defaultOpts()
		opts.Temporary = Bool(true)
		opts.IfNotExists = Bool(true)
		opts.ExternalStageParams = ExternalS3StageParams{
			Url:               "some url",
			AwsAccessPointArn: String("aws-access-point-arn"),
			Credentials: &ExternalStageS3Credentials{
				AwsKeyId:     String("aws-key-id"),
				AwsSecretKey: String("aws-secret-key"),
				AwsToken:     String("aws-token"),
			},
			Encryption: &ExternalStageS3Encryption{
				AwsSseKms: &ExternalStageS3EncryptionAwsSseKms{
					KmsKeyId: String("kms-key-id"),
				},
			},
			UsePrivatelinkEndpoint: Bool(true),
		}
		opts.DirectoryTableOptions = &StageS3CommonDirectoryTableOptions{
			Enable:          true,
			RefreshOnCreate: Bool(true),
			AutoRefresh:     Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE TEMPORARY STAGE IF NOT EXISTS %s URL = 'some url' AWS_ACCESS_POINT_ARN = 'aws-access-point-arn' CREDENTIALS = (AWS_KEY_ID = 'aws-key-id' AWS_SECRET_KEY = 'aws-secret-key' AWS_TOKEN = 'aws-token') ENCRYPTION = (TYPE = 'AWS_SSE_KMS' KMS_KEY_ID = 'kms-key-id') USE_PRIVATELINK_ENDPOINT = true DIRECTORY = (ENABLE = true REFRESH_ON_CREATE = true AUTO_REFRESH = true)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: AwsSseS3", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageS3Encryption{
			AwsSseS3: &ExternalStageS3EncryptionAwsSseS3{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENCRYPTION = (TYPE = 'AWS_SSE_S3')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: None", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageS3Encryption{
			None: &ExternalStageS3EncryptionNone{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENCRYPTION = (TYPE = 'NONE')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("credentials: AwsRole", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Credentials = &ExternalStageS3Credentials{
			AwsRole: String("arn:aws:iam::123456789012:role/MyRole"),
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' CREDENTIALS = (AWS_ROLE = 'arn:aws:iam::123456789012:role/MyRole')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = CSV)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = JSON)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = AVRO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = ORC)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = PARQUET)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' FILE_FORMAT = (TYPE = XML)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnS3StageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnS3StageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_CreateOnGCS(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateOnGCSStageOptions
	defaultOpts := func() *CreateOnGCSStageOptions {
		return &CreateOnGCSStageOptions{
			name: id,
			ExternalStageParams: ExternalGCSStageParams{
				Url: "gcs://example.com",
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateOnGCSStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnGCSStageOptions", "OrReplace", "IfNotExists"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageGCSEncryption{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnGCSStageOptions.ExternalStageParams.Encryption", "GcsSseKms", "None"))
	})

	// adjusted manually
	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE STAGE %s URL = 'gcs://example.com'", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.Temporary = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalGCSStageParams{
			Url:                "some url",
			StorageIntegration: integrationId,
			Encryption: &ExternalStageGCSEncryption{
				GcsSseKms: &ExternalStageGCSEncryptionGcsSseKms{
					KmsKeyId: String("kms-key-id"),
				},
			},
		}
		opts.DirectoryTableOptions = &ExternalGCSDirectoryTableOptions{
			Enable:                  true,
			RefreshOnCreate:         Bool(true),
			AutoRefresh:             Bool(true),
			NotificationIntegration: String("notification-integration"),
		}
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE TEMPORARY STAGE %s URL = 'some url' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'GCS_SSE_KMS' KMS_KEY_ID = 'kms-key-id') DIRECTORY = (ENABLE = true REFRESH_ON_CREATE = true AUTO_REFRESH = true NOTIFICATION_INTEGRATION = 'notification-integration') FILE_FORMAT = (TYPE = CSV) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: None", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageGCSEncryption{
			None: &ExternalStageGCSEncryptionNone{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' ENCRYPTION = (TYPE = 'NONE')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = CSV)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = JSON)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = AVRO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = ORC)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = PARQUET)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'gcs://example.com' FILE_FORMAT = (TYPE = XML)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnGCSStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnGCSStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_CreateOnAzure(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateOnAzureStageOptions
	defaultOpts := func() *CreateOnAzureStageOptions {
		return &CreateOnAzureStageOptions{
			name: id,
			ExternalStageParams: ExternalAzureStageParams{
				Url: "azure://example.com",
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateOnAzureStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnAzureStageOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.Credentials]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalAzureStageParams{
			StorageIntegration: &integrationId,
			Credentials: &ExternalStageAzureCredentials{
				AzureSasToken: "azure-sas-token",
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnAzureStageOptions.ExternalStageParams", "StorageIntegration", "Credentials"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.UsePrivatelinkEndpoint]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalAzureStageParams{
			StorageIntegration:     &integrationId,
			UsePrivatelinkEndpoint: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnAzureStageOptions.ExternalStageParams", "StorageIntegration", "UsePrivatelinkEndpoint"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageAzureEncryption{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnAzureStageOptions.ExternalStageParams.Encryption", "AzureCse", "None"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE STAGE %s URL = 'azure://example.com'", id.FullyQualifiedName())
	})

	// variants added manually
	t.Run("all options - storage integration", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.Temporary = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = ExternalAzureStageParams{
			Url:                "some url",
			StorageIntegration: &integrationId,
			Encryption: &ExternalStageAzureEncryption{
				AzureCse: &ExternalStageAzureEncryptionAzureCse{
					MasterKey: "master-key",
				},
			},
		}
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE TEMPORARY STAGE %s URL = 'some url' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'AZURE_CSE' MASTER_KEY = 'master-key') FILE_FORMAT = (TYPE = CSV) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	t.Run("all options - directory table and credentials", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfNotExists = Bool(true)
		opts.DirectoryTableOptions = &ExternalAzureDirectoryTableOptions{
			Enable:                  true,
			RefreshOnCreate:         Bool(true),
			AutoRefresh:             Bool(true),
			NotificationIntegration: String("notification-integration"),
		}
		opts.ExternalStageParams = ExternalAzureStageParams{
			Url: "some url",
			Credentials: &ExternalStageAzureCredentials{
				AzureSasToken: "azure-sas-token",
			},
			Encryption: &ExternalStageAzureEncryption{
				AzureCse: &ExternalStageAzureEncryptionAzureCse{
					MasterKey: "master-key",
				},
			},
			UsePrivatelinkEndpoint: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE IF NOT EXISTS %s URL = 'some url' CREDENTIALS = (AZURE_SAS_TOKEN = 'azure-sas-token') ENCRYPTION = (TYPE = 'AZURE_CSE' MASTER_KEY = 'master-key') USE_PRIVATELINK_ENDPOINT = true DIRECTORY = (ENABLE = true REFRESH_ON_CREATE = true AUTO_REFRESH = true NOTIFICATION_INTEGRATION = 'notification-integration')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: None", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams.Encryption = &ExternalStageAzureEncryption{
			None: &ExternalStageAzureEncryptionNone{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' ENCRYPTION = (TYPE = 'NONE')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = CSV)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = JSON)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = AVRO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = ORC)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = PARQUET)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 'azure://example.com' FILE_FORMAT = (TYPE = XML)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnAzureStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnAzureStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_CreateOnS3Compatible(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateOnS3CompatibleStageOptions
	defaultOpts := func() *CreateOnS3CompatibleStageOptions {
		return &CreateOnS3CompatibleStageOptions{
			name: id,
			ExternalStageParams: ExternalS3CompatibleStageParams{
				Url:      "s3://example.com",
				Endpoint: "some endpoint",
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateOnS3CompatibleStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateOnS3CompatibleStageOptions", "OrReplace", "IfNotExists"))
	})

	// adjusted manually
	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint'", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Temporary = Bool(true)
		opts.IfNotExists = Bool(true)
		opts.ExternalStageParams = ExternalS3CompatibleStageParams{
			Url:      "some url",
			Endpoint: "some endpoint",
			Credentials: &ExternalStageS3CompatibleCredentials{
				AwsKeyId:     "aws-key-id",
				AwsSecretKey: "aws-secret-key",
			},
		}
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		opts.Comment = String("some comment")
		opts.DirectoryTableOptions = &StageS3CommonDirectoryTableOptions{
			Enable:          true,
			RefreshOnCreate: Bool(true),
			AutoRefresh:     Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE TEMPORARY STAGE IF NOT EXISTS %s URL = 'some url' ENDPOINT = 'some endpoint' CREDENTIALS = (AWS_KEY_ID = 'aws-key-id' AWS_SECRET_KEY = 'aws-secret-key') DIRECTORY = (ENABLE = true REFRESH_ON_CREATE = true AUTO_REFRESH = true) FILE_FORMAT = (TYPE = CSV) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = CSV)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = JSON)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: AVRO basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			AvroOptions: &StageFileFormatAvroOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = AVRO)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: ORC basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			OrcOptions: &StageFileFormatOrcOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = ORC)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: Parquet basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			ParquetOptions: &StageFileFormatParquetOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = PARQUET)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: XML basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			XmlOptions: &StageFileFormatXmlOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE STAGE %s URL = 's3://example.com' ENDPOINT = 'some endpoint' FILE_FORMAT = (TYPE = XML)`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnS3CompatibleStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateOnS3CompatibleStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterStageOptions
	defaultOpts := func() *AlterStageOptions {
		return &AlterStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.RenameTo] if set", func(t *testing.T) {
		opts := defaultOpts()
		opts.RenameTo = &emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.RenameTo opts.SetTags opts.UnsetTags] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterStageOptions", "RenameTo", "SetTags", "UnsetTags"))
	})

	t.Run("validation: exactly one field from [opts.RenameTo opts.SetTags opts.UnsetTags] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		opts.RenameTo = new(SchemaObjectIdentifier)
		opts.SetTags = []TagAssociation{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterStageOptions", "RenameTo", "SetTags", "UnsetTags"))
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	// variants added manually
	t.Run("rename", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		newId := randomSchemaObjectIdentifier()
		opts.RenameTo = &newId
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE IF EXISTS %s RENAME TO %s", id.FullyQualifiedName(), newId.FullyQualifiedName())
	})

	t.Run("set tags", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.SetTags = []TagAssociation{
			{
				Name:  NewAccountObjectIdentifier("tag-name"),
				Value: "tag-value",
			},
			{
				Name:  NewAccountObjectIdentifier("tag-name2"),
				Value: "tag-value2",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s SET TAG "tag-name" = 'tag-value', "tag-name2" = 'tag-value2'`, id.FullyQualifiedName())
	})

	t.Run("unset tags", func(t *testing.T) {
		opts := defaultOpts()
		opts.UnsetTags = []ObjectIdentifier{
			NewAccountObjectIdentifier("tag-name"),
			NewAccountObjectIdentifier("tag-name2"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s UNSET TAG "tag-name", "tag-name2"`, id.FullyQualifiedName())
	})
}

func TestStages_AlterInternalStage(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterInternalStageStageOptions
	defaultOpts := func() *AlterInternalStageStageOptions {
		return &AlterInternalStageStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterInternalStageStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	// basic removed manually

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE IF EXISTS %s SET FILE_FORMAT = (TYPE = CSV) COMMENT = 'some comment'", id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = JSON)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterInternalStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterInternalStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_AlterExternalS3Stage(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterExternalS3StageStageOptions
	defaultOpts := func() *AlterExternalS3StageStageOptions {
		return &AlterExternalS3StageStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterExternalS3StageStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.Credentials]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalS3StageParams{
			StorageIntegration: &integrationId,
			Credentials: &ExternalStageS3Credentials{
				AwsRole: String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalS3StageStageOptions.ExternalStageParams", "StorageIntegration", "Credentials"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsKeyId opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsKeyId: String("aws-key-id"),
				AwsRole:  String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalS3StageStageOptions.ExternalStageParams.Credentials", "AwsKeyId", "AwsRole"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsSecretKey opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsSecretKey: String("aws-secret-key"),
				AwsRole:      String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalS3StageStageOptions.ExternalStageParams.Credentials", "AwsSecretKey", "AwsRole"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.Credentials.AwsToken opts.ExternalStageParams.Credentials.AwsRole]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Credentials: &ExternalStageS3Credentials{
				AwsToken: String("aws-token"),
				AwsRole:  String("aws-role"),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalS3StageStageOptions.ExternalStageParams.Credentials", "AwsToken", "AwsRole"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.UsePrivatelinkEndpoint]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalS3StageParams{
			StorageIntegration:     &integrationId,
			UsePrivatelinkEndpoint: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalS3StageStageOptions.ExternalStageParams", "StorageIntegration", "UsePrivatelinkEndpoint"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Url:        "s3://example.com",
			Encryption: &ExternalStageS3Encryption{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalS3StageStageOptions.ExternalStageParams.Encryption", "AwsCse", "AwsSseS3", "AwsSseKms", "None"))
	})

	// basic removed manually

	// added manually
	t.Run("credentials", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Url: "s3://example.com",
			Credentials: &ExternalStageS3Credentials{
				AwsKeyId:     String("aws-key-id"),
				AwsSecretKey: String("aws-secret-key"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET URL = 's3://example.com' CREDENTIALS = (AWS_KEY_ID = 'aws-key-id' AWS_SECRET_KEY = 'aws-secret-key')", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalS3StageParams{
			// is URL required?
			Url:                "some url",
			AwsAccessPointArn:  String("aws-access-point-arn"),
			StorageIntegration: &integrationId,
			Encryption: &ExternalStageS3Encryption{
				None: &ExternalStageS3EncryptionNone{},
			},
		}
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s SET URL = 'some url' AWS_ACCESS_POINT_ARN = 'aws-access-point-arn' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'NONE') FILE_FORMAT = (TYPE = JSON) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: AwsSseS3", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Url: "s3://example.com",
			Encryption: &ExternalStageS3Encryption{
				AwsSseS3: &ExternalStageS3EncryptionAwsSseS3{},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s SET URL = 's3://example.com' ENCRYPTION = (TYPE = 'AWS_SSE_S3')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: AwsSseKms", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Url: "s3://example.com",
			Encryption: &ExternalStageS3Encryption{
				AwsSseKms: &ExternalStageS3EncryptionAwsSseKms{
					KmsKeyId: String("kms-key-id"),
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s SET URL = 's3://example.com' ENCRYPTION = (TYPE = 'AWS_SSE_KMS' KMS_KEY_ID = 'kms-key-id')`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("credentials: AwsRole", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalS3StageParams{
			Url: "s3://example.com",
			Credentials: &ExternalStageS3Credentials{
				AwsRole: String("arn:aws:iam::123456789012:role/MyRole"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s SET URL = 's3://example.com' CREDENTIALS = (AWS_ROLE = 'arn:aws:iam::123456789012:role/MyRole')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = CSV)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = JSON)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalS3StageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalS3StageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_AlterExternalGCSStage(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterExternalGCSStageStageOptions
	defaultOpts := func() *AlterExternalGCSStageStageOptions {
		return &AlterExternalGCSStageStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterExternalGCSStageStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalGCSStageParams{
			Url:                "gcs://example.com",
			StorageIntegration: integrationId,
			Encryption:         &ExternalStageGCSEncryption{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalGCSStageStageOptions.ExternalStageParams.Encryption", "GcsSseKms", "None"))
	})

	// basic removed manually

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalGCSStageParams{
			Url:                "some url",
			StorageIntegration: integrationId,
			Encryption: &ExternalStageGCSEncryption{
				None: &ExternalStageGCSEncryptionNone{},
			},
		}
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s SET URL = 'some url' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'NONE') FILE_FORMAT = (TYPE = JSON) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: GcsSseKms", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalGCSStageParams{
			Url:                "gcs://example.com",
			StorageIntegration: integrationId,
			Encryption: &ExternalStageGCSEncryption{
				GcsSseKms: &ExternalStageGCSEncryptionGcsSseKms{
					KmsKeyId: String("kms-key-id"),
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s SET URL = 'gcs://example.com' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'GCS_SSE_KMS' KMS_KEY_ID = 'kms-key-id')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = CSV)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = JSON)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalGCSStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalGCSStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_AlterExternalAzureStage(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterExternalAzureStageStageOptions
	defaultOpts := func() *AlterExternalAzureStageStageOptions {
		return &AlterExternalAzureStageStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterExternalAzureStageStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.Credentials]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integrationId")
		opts.ExternalStageParams = &ExternalAzureStageParams{
			StorageIntegration: &integrationId,
			Credentials:        &ExternalStageAzureCredentials{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalAzureStageStageOptions.ExternalStageParams", "StorageIntegration", "Credentials"))
	})

	t.Run("validation: conflicting fields for [opts.ExternalStageParams.StorageIntegration opts.ExternalStageParams.UsePrivatelinkEndpoint]", func(t *testing.T) {
		opts := defaultOpts()
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalAzureStageParams{
			StorageIntegration:     &integrationId,
			UsePrivatelinkEndpoint: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterExternalAzureStageStageOptions.ExternalStageParams", "StorageIntegration", "UsePrivatelinkEndpoint"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.ExternalStageParams.Encryption...] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalAzureStageParams{
			Url:        "azure://example.com",
			Encryption: &ExternalStageAzureEncryption{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalAzureStageStageOptions.ExternalStageParams.Encryption", "AzureCse", "None"))
	})

	// basic removed manually

	// added manually
	t.Run("credentials", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalAzureStageParams{
			Url: "azure://example.com",
			Credentials: &ExternalStageAzureCredentials{
				AzureSasToken: "azure-sas-token",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET URL = 'azure://example.com' CREDENTIALS = (AZURE_SAS_TOKEN = 'azure-sas-token')", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		integrationId := NewAccountObjectIdentifier("integration")
		opts.ExternalStageParams = &ExternalAzureStageParams{
			Url:                "some url",
			StorageIntegration: &integrationId,
			Encryption: &ExternalStageAzureEncryption{
				None: &ExternalStageAzureEncryptionNone{},
			},
		}
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		opts.Comment = String("some comment")
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s SET URL = 'some url' STORAGE_INTEGRATION = "integration" ENCRYPTION = (TYPE = 'NONE') FILE_FORMAT = (TYPE = JSON) COMMENT = 'some comment'`, id.FullyQualifiedName())
	})

	// added manually
	t.Run("encryption: AzureCse", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExternalStageParams = &ExternalAzureStageParams{
			Url: "azure://example.com",
			Encryption: &ExternalStageAzureEncryption{
				AzureCse: &ExternalStageAzureEncryptionAzureCse{
					MasterKey: "master-key",
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE %s SET URL = 'azure://example.com' ENCRYPTION = (TYPE = 'AZURE_CSE' MASTER_KEY = 'master-key')`, id.FullyQualifiedName())
	})

	// added manually - file format tests
	t.Run("file format: CSV basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions: &StageFileFormatCsvOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = CSV)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("file format: JSON basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER STAGE %s SET FILE_FORMAT = (TYPE = JSON)", id.FullyQualifiedName())
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - none set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalAzureStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})

	// added manually
	t.Run("validation: exactly one field from [opts.FileFormat.*] should be present - multiple set", func(t *testing.T) {
		opts := defaultOpts()
		opts.FileFormat = &StageFileFormat{
			CsvOptions:  &StageFileFormatCsvOptions{},
			JsonOptions: &StageFileFormatJsonOptions{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterExternalAzureStageStageOptions.FileFormat", "FormatName", "CsvOptions", "JsonOptions", "AvroOptions", "OrcOptions", "ParquetOptions", "XmlOptions"))
	})
}

func TestStages_AlterDirectoryTable(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterDirectoryTableStageOptions
	defaultOpts := func() *AlterDirectoryTableStageOptions {
		return &AlterDirectoryTableStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterDirectoryTableStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.SetDirectory opts.Refresh]", func(t *testing.T) {
		opts := defaultOpts()
		opts.SetDirectory = &DirectoryTableSet{}
		opts.Refresh = &DirectoryTableRefresh{}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterDirectoryTableStageOptions", "SetDirectory", "Refresh"))
	})

	// variants added manually
	t.Run("set directory", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.SetDirectory = &DirectoryTableSet{
			Enable: true,
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s SET DIRECTORY = (ENABLE = true)`, id.FullyQualifiedName())
	})

	t.Run("refresh - basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Refresh = &DirectoryTableRefresh{}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s REFRESH`, id.FullyQualifiedName())
	})

	t.Run("refresh - all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Refresh = &DirectoryTableRefresh{
			Subpath: String("subpath"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STAGE IF EXISTS %s REFRESH SUBPATH = 'subpath'`, id.FullyQualifiedName())
	})
}

func TestStages_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DropStageOptions
	defaultOpts := func() *DropStageOptions {
		return &DropStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DROP STAGE %s", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, "DROP STAGE IF EXISTS %s", id.FullyQualifiedName())
	})
}

func TestStages_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DescribeStageOptions
	defaultOpts := func() *DescribeStageOptions {
		return &DescribeStageOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DESCRIBE STAGE %s", id.FullyQualifiedName())
	})

	// all options removed manually
}

func TestStages_Show(t *testing.T) {
	// added manually
	schemaId := randomDatabaseObjectIdentifier()

	// Minimal valid ShowStageOptions
	defaultOpts := func() *ShowStageOptions {
		return &ShowStageOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowStageOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "SHOW STAGES")
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{
			Pattern: String("some pattern"),
		}
		opts.In = &ExtendedIn{
			In: In{
				Schema: schemaId,
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STAGES LIKE 'some pattern' IN SCHEMA %s`, schemaId.FullyQualifiedName())
	})

	// added manually
	t.Run("with Like only", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{
			Pattern: String("stage_pattern"),
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STAGES LIKE 'stage_pattern'`)
	})

	// added manually
	t.Run("with In only", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &ExtendedIn{
			In: In{
				Schema: schemaId,
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STAGES IN SCHEMA %s`, schemaId.FullyQualifiedName())
	})
}

// added manually
func TestToStageFileFormatCsvCompression(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatCsvCompression
		Error    string
	}{
		{Input: string(StageFileFormatCsvCompressionAuto), Expected: StageFileFormatCsvCompressionAuto},
		{Input: string(StageFileFormatCsvCompressionGzip), Expected: StageFileFormatCsvCompressionGzip},
		{Input: string(StageFileFormatCsvCompressionBz2), Expected: StageFileFormatCsvCompressionBz2},
		{Input: string(StageFileFormatCsvCompressionBrotli), Expected: StageFileFormatCsvCompressionBrotli},
		{Input: string(StageFileFormatCsvCompressionZstd), Expected: StageFileFormatCsvCompressionZstd},
		{Input: string(StageFileFormatCsvCompressionDeflate), Expected: StageFileFormatCsvCompressionDeflate},
		{Input: string(StageFileFormatCsvCompressionRawDeflate), Expected: StageFileFormatCsvCompressionRawDeflate},
		{Input: string(StageFileFormatCsvCompressionNone), Expected: StageFileFormatCsvCompressionNone},
		{Name: "lowercase: gzip", Input: "gzip", Expected: StageFileFormatCsvCompressionGzip},
		{Name: "mixed case: Gzip", Input: "Gzip", Expected: StageFileFormatCsvCompressionGzip},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format CSV compression"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format CSV compression"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatCsvCompression(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}

// added manually
func TestToStageFileFormatJsonCompression(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatJsonCompression
		Error    string
	}{
		{Input: string(StageFileFormatJsonCompressionAuto), Expected: StageFileFormatJsonCompressionAuto},
		{Input: string(StageFileFormatJsonCompressionGzip), Expected: StageFileFormatJsonCompressionGzip},
		{Input: string(StageFileFormatJsonCompressionBz2), Expected: StageFileFormatJsonCompressionBz2},
		{Input: string(StageFileFormatJsonCompressionBrotli), Expected: StageFileFormatJsonCompressionBrotli},
		{Input: string(StageFileFormatJsonCompressionZstd), Expected: StageFileFormatJsonCompressionZstd},
		{Input: string(StageFileFormatJsonCompressionDeflate), Expected: StageFileFormatJsonCompressionDeflate},
		{Input: string(StageFileFormatJsonCompressionRawDeflate), Expected: StageFileFormatJsonCompressionRawDeflate},
		{Input: string(StageFileFormatJsonCompressionNone), Expected: StageFileFormatJsonCompressionNone},
		{Name: "lowercase: brotli", Input: "brotli", Expected: StageFileFormatJsonCompressionBrotli},
		{Name: "mixed case: Brotli", Input: "Brotli", Expected: StageFileFormatJsonCompressionBrotli},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format JSON compression"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format JSON compression"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatJsonCompression(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}

// added manually
func TestToStageFileFormatAvroCompression(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatAvroCompression
		Error    string
	}{
		{Input: string(StageFileFormatAvroCompressionAuto), Expected: StageFileFormatAvroCompressionAuto},
		{Input: string(StageFileFormatAvroCompressionGzip), Expected: StageFileFormatAvroCompressionGzip},
		{Input: string(StageFileFormatAvroCompressionBrotli), Expected: StageFileFormatAvroCompressionBrotli},
		{Input: string(StageFileFormatAvroCompressionZstd), Expected: StageFileFormatAvroCompressionZstd},
		{Input: string(StageFileFormatAvroCompressionDeflate), Expected: StageFileFormatAvroCompressionDeflate},
		{Input: string(StageFileFormatAvroCompressionRawDeflate), Expected: StageFileFormatAvroCompressionRawDeflate},
		{Input: string(StageFileFormatAvroCompressionNone), Expected: StageFileFormatAvroCompressionNone},
		{Name: "lowercase: zstd", Input: "zstd", Expected: StageFileFormatAvroCompressionZstd},
		{Name: "mixed case: Zstd", Input: "Zstd", Expected: StageFileFormatAvroCompressionZstd},
		{Name: "invalid: bz2 (not supported for AVRO)", Input: "BZ2", Error: "invalid stage file format AVRO compression"},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format AVRO compression"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format AVRO compression"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatAvroCompression(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}

// added manually
func TestToStageFileFormatParquetCompression(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatParquetCompression
		Error    string
	}{
		{Input: string(StageFileFormatParquetCompressionAuto), Expected: StageFileFormatParquetCompressionAuto},
		{Input: string(StageFileFormatParquetCompressionLzo), Expected: StageFileFormatParquetCompressionLzo},
		{Input: string(StageFileFormatParquetCompressionSnappy), Expected: StageFileFormatParquetCompressionSnappy},
		{Input: string(StageFileFormatParquetCompressionNone), Expected: StageFileFormatParquetCompressionNone},
		{Name: "lowercase: snappy", Input: "snappy", Expected: StageFileFormatParquetCompressionSnappy},
		{Name: "mixed case: Snappy", Input: "Snappy", Expected: StageFileFormatParquetCompressionSnappy},
		{Name: "invalid: gzip (not supported for Parquet)", Input: "GZIP", Error: "invalid stage file format Parquet compression"},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format Parquet compression"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format Parquet compression"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatParquetCompression(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}

// added manually
func TestToStageFileFormatXmlCompression(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatXmlCompression
		Error    string
	}{
		{Input: string(StageFileFormatXmlCompressionAuto), Expected: StageFileFormatXmlCompressionAuto},
		{Input: string(StageFileFormatXmlCompressionGzip), Expected: StageFileFormatXmlCompressionGzip},
		{Input: string(StageFileFormatXmlCompressionBz2), Expected: StageFileFormatXmlCompressionBz2},
		{Input: string(StageFileFormatXmlCompressionBrotli), Expected: StageFileFormatXmlCompressionBrotli},
		{Input: string(StageFileFormatXmlCompressionZstd), Expected: StageFileFormatXmlCompressionZstd},
		{Input: string(StageFileFormatXmlCompressionDeflate), Expected: StageFileFormatXmlCompressionDeflate},
		{Input: string(StageFileFormatXmlCompressionRawDeflate), Expected: StageFileFormatXmlCompressionRawDeflate},
		{Input: string(StageFileFormatXmlCompressionNone), Expected: StageFileFormatXmlCompressionNone},
		{Name: "lowercase: deflate", Input: "deflate", Expected: StageFileFormatXmlCompressionDeflate},
		{Name: "mixed case: Deflate", Input: "Deflate", Expected: StageFileFormatXmlCompressionDeflate},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format XML compression"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format XML compression"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatXmlCompression(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}

// added manually
func TestToStageFileFormatBinaryFormat(t *testing.T) {
	testCases := []struct {
		Name     string
		Input    string
		Expected StageFileFormatBinaryFormat
		Error    string
	}{
		{Input: string(StageFileFormatBinaryFormatHex), Expected: StageFileFormatBinaryFormatHex},
		{Input: string(StageFileFormatBinaryFormatBase64), Expected: StageFileFormatBinaryFormatBase64},
		{Input: string(StageFileFormatBinaryFormatUtf8), Expected: StageFileFormatBinaryFormatUtf8},
		{Name: "lowercase: hex", Input: "hex", Expected: StageFileFormatBinaryFormatHex},
		{Name: "lowercase: base64", Input: "base64", Expected: StageFileFormatBinaryFormatBase64},
		{Name: "lowercase: utf8", Input: "utf8", Expected: StageFileFormatBinaryFormatUtf8},
		{Name: "mixed case: Hex", Input: "Hex", Expected: StageFileFormatBinaryFormatHex},
		{Name: "invalid: incorrect", Input: "incorrect", Error: "invalid stage file format binary format"},
		{Name: "invalid: empty", Input: "", Error: "invalid stage file format binary format"},
	}
	for _, tc := range testCases {
		name := tc.Name
		if name == "" {
			name = tc.Input
		}
		t.Run(name, func(t *testing.T) {
			result, err := ToStageFileFormatBinaryFormat(tc.Input)
			if tc.Error != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.Error)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.Expected, result)
			}
		})
	}
}
