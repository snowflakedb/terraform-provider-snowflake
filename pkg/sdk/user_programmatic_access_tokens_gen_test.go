// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

// imports adjusted manually
import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestUserProgrammaticAccessTokens_Add(t *testing.T) {
	// adjusted manually
	name := randomAccountObjectIdentifier()
	roleId := randomAccountObjectIdentifier()
	userId := randomAccountObjectIdentifier()
	// Minimal valid AddUserProgrammaticAccessTokenOptions
	defaultOpts := func() *AddUserProgrammaticAccessTokenOptions {
		return &AddUserProgrammaticAccessTokenOptions{
			// adjusted manually
			name:     name,
			UserName: userId,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AddUserProgrammaticAccessTokenOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.UserName]", func(t *testing.T) {
		opts := defaultOpts()
		opts.UserName = emptyAccountObjectIdentifier
		// error adjusted manually
		assertOptsInvalidJoinedErrors(t, opts, errInvalidIdentifier("AddUserProgrammaticAccessTokenOptions", "UserName"))
	})

	t.Run("validation: valid identifier for [opts.RoleRestriction] if set", func(t *testing.T) {
		opts := defaultOpts()
		opts.RoleRestriction = &emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	// validations added manually
	t.Run("validation: invalid days to expiry", func(t *testing.T) {
		opts := defaultOpts()
		opts.DaysToExpiry = Int(0)
		assertOptsInvalidJoinedErrors(t, opts, errIntValue("AddUserProgrammaticAccessTokenOptions", "DaysToExpiry", IntErrGreaterOrEqual, 1))
	})

	t.Run("validation: invalid mins to bypass network policy requirement", func(t *testing.T) {
		opts := defaultOpts()
		opts.MinsToBypassNetworkPolicyRequirement = Int(0)
		assertOptsInvalidJoinedErrors(t, opts, errIntValue("AddUserProgrammaticAccessTokenOptions", "MinsToBypassNetworkPolicyRequirement", IntErrGreaterOrEqual, 1))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s ADD PROGRAMMATIC ACCESS TOKEN %s`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.RoleRestriction = &roleId
		opts.DaysToExpiry = Int(30)
		opts.MinsToBypassNetworkPolicyRequirement = Int(10)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s ADD PROGRAMMATIC ACCESS TOKEN %s ROLE_RESTRICTION = %s DAYS_TO_EXPIRY = 30 MINS_TO_BYPASS_NETWORK_POLICY_REQUIREMENT = 10 COMMENT = 'test comment'`, userId.FullyQualifiedName(), name.FullyQualifiedName(), roleId.FullyQualifiedName())
	})
}

func TestUserProgrammaticAccessTokens_Modify(t *testing.T) {
	// adjusted manually
	name := randomAccountObjectIdentifier()
	userId := randomAccountObjectIdentifier()
	// Minimal valid ModifyUserProgrammaticAccessTokenOptions
	defaultOpts := func() *ModifyUserProgrammaticAccessTokenOptions {
		return &ModifyUserProgrammaticAccessTokenOptions{
			// adjusted manually
			name:     name,
			UserName: userId,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ModifyUserProgrammaticAccessTokenOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.UserName]", func(t *testing.T) {
		opts := defaultOpts()
		opts.UserName = emptyAccountObjectIdentifier
		// error adjusted manually
		assertOptsInvalidJoinedErrors(t, opts, errInvalidIdentifier("ModifyUserProgrammaticAccessTokenOptions", "UserName"))
	})

	t.Run("validation: exactly one field from [opts.Set opts.Unset opts.RenameTo] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("ModifyUserProgrammaticAccessTokenOptions", "Set", "Unset", "RenameTo"))
	})

	t.Run("validation: exactly one field from [opts.Set opts.Unset opts.RenameTo] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		newId := randomAccountObjectIdentifier()
		opts.RenameTo = &newId
		opts.Set = new(ModifyProgrammaticAccessTokenSet)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("ModifyUserProgrammaticAccessTokenOptions", "Set", "Unset", "RenameTo"))
	})

	// validation added manually
	t.Run("validation: invalid mins to bypass network policy requirement", func(t *testing.T) {
		opts := &ModifyUserProgrammaticAccessTokenOptions{
			name: name,
			Set: &ModifyProgrammaticAccessTokenSet{
				MinsToBypassNetworkPolicyRequirement: Int(0),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errIntValue("ModifyUserProgrammaticAccessTokenOptions", "Set.MinsToBypassNetworkPolicyRequirement", IntErrGreaterOrEqual, 1))
	})

	// variants added manually
	t.Run("with rename to", func(t *testing.T) {
		opts := defaultOpts()
		newId := randomAccountObjectIdentifier()
		opts.RenameTo = &newId
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s MODIFY PROGRAMMATIC ACCESS TOKEN %s RENAME TO %s`, userId.FullyQualifiedName(), name.FullyQualifiedName(), newId.FullyQualifiedName())
	})

	t.Run("with set: all attributes", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &ModifyProgrammaticAccessTokenSet{
			Disabled:                             Bool(true),
			MinsToBypassNetworkPolicyRequirement: Int(10),
			Comment:                              String("new comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s MODIFY PROGRAMMATIC ACCESS TOKEN %s SET DISABLED = true MINS_TO_BYPASS_NETWORK_POLICY_REQUIREMENT = 10 COMMENT = 'new comment'`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})

	t.Run("with unset: all attributes", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &ModifyProgrammaticAccessTokenUnset{
			Disabled:                             Bool(true),
			MinsToBypassNetworkPolicyRequirement: Bool(true),
			Comment:                              Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s MODIFY PROGRAMMATIC ACCESS TOKEN %s UNSET DISABLED, MINS_TO_BYPASS_NETWORK_POLICY_REQUIREMENT, COMMENT`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})
}

func TestUserProgrammaticAccessTokens_Rotate(t *testing.T) {
	// adjusted manually
	name := randomAccountObjectIdentifier()
	userId := randomAccountObjectIdentifier()
	// Minimal valid RotateUserProgrammaticAccessTokenOptions
	defaultOpts := func() *RotateUserProgrammaticAccessTokenOptions {
		return &RotateUserProgrammaticAccessTokenOptions{
			// adjusted manually
			name:     name,
			UserName: userId,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*RotateUserProgrammaticAccessTokenOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.UserName]", func(t *testing.T) {
		opts := defaultOpts()
		opts.UserName = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	// validation added manually
	t.Run("validation: invalid expire rotated token after hours", func(t *testing.T) {
		opts := &RotateUserProgrammaticAccessTokenOptions{
			name:                         name,
			ExpireRotatedTokenAfterHours: Int(-1),
		}
		assertOptsInvalidJoinedErrors(t, opts, errIntValue("RotateUserProgrammaticAccessTokenOptions", "ExpireRotatedTokenAfterHours", IntErrGreaterOrEqual, 0))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s ROTATE PROGRAMMATIC ACCESS TOKEN %s`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.ExpireRotatedTokenAfterHours = Int(1)
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s ROTATE PROGRAMMATIC ACCESS TOKEN %s EXPIRE_ROTATED_TOKEN_AFTER_HOURS = 1`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})
}

func TestUserProgrammaticAccessTokens_Remove(t *testing.T) {
	// adjusted manually
	name := randomAccountObjectIdentifier()
	userId := randomAccountObjectIdentifier()
	// Minimal valid RemoveUserProgrammaticAccessTokenOptions
	defaultOpts := func() *RemoveUserProgrammaticAccessTokenOptions {
		return &RemoveUserProgrammaticAccessTokenOptions{
			// adjusted manually
			name:     name,
			UserName: userId,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*RemoveUserProgrammaticAccessTokenOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.UserName]", func(t *testing.T) {
		opts := defaultOpts()
		opts.UserName = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `ALTER USER %s REMOVE PROGRAMMATIC ACCESS TOKEN %s`, userId.FullyQualifiedName(), name.FullyQualifiedName())
	})

	// all options removed manually
}

func TestUserProgrammaticAccessTokens_Show(t *testing.T) {
	// added manually
	id := randomAccountObjectIdentifier()

	// Minimal valid ShowUserProgrammaticAccessTokenOptions
	defaultOpts := func() *ShowUserProgrammaticAccessTokenOptions {
		return &ShowUserProgrammaticAccessTokenOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowUserProgrammaticAccessTokenOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `SHOW USER PROGRAMMATIC ACCESS TOKENS`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.UserName = &id
		assertOptsValidAndSQLEquals(t, opts, `SHOW USER PROGRAMMATIC ACCESS TOKENS FOR USER %s`, id.FullyQualifiedName())
	})
}

// test added manually
func Test_ProgrammaticAccessTokenStatus(t *testing.T) {
	type test struct {
		input string
		want  ProgrammaticAccessTokenStatus
	}

	valid := []test{
		// case insensitive.
		{input: "active", want: ProgrammaticAccessTokenStatusActive},

		// Supported Values
		{input: "ACTIVE", want: ProgrammaticAccessTokenStatusActive},
		{input: "EXPIRED", want: ProgrammaticAccessTokenStatusExpired},
		{input: "DISABLED", want: ProgrammaticAccessTokenStatusDisabled},
	}

	invalid := []test{
		// bad values
		{input: ""},
		{input: "foo"},
	}

	for _, tc := range valid {
		t.Run(tc.input, func(t *testing.T) {
			got, err := toProgrammaticAccessTokenStatus(tc.input)
			require.NoError(t, err)
			require.Equal(t, tc.want, got)
		})
	}

	for _, tc := range invalid {
		t.Run(tc.input, func(t *testing.T) {
			_, err := toProgrammaticAccessTokenStatus(tc.input)
			require.Error(t, err)
		})
	}
}
