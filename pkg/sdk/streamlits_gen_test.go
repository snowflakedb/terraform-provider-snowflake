// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

func TestStreamlits_Create(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateStreamlitOptions
	defaultOpts := func() *CreateStreamlitOptions {
		return &CreateStreamlitOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateStreamlitOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.QueryWarehouse] if set", func(t *testing.T) {
		opts := defaultOpts()
		opts.QueryWarehouse = &emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.IfNotExists opts.OrReplace]", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfNotExists = Bool(true)
		opts.OrReplace = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateStreamlitOptions", "IfNotExists", "OrReplace"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.RootLocation = "@test"
		opts.MainFile = "manifest.yml"
		assertOptsValidAndSQLEquals(t, opts, `CREATE STREAMLIT %s ROOT_LOCATION = '@test' MAIN_FILE = 'manifest.yml'`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		warehouse := NewAccountObjectIdentifier("test_warehouse")
		opts.IfNotExists = Bool(true)
		opts.RootLocation = "@test"
		opts.MainFile = "manifest.yml"
		opts.QueryWarehouse = &warehouse
		opts.Comment = String("test")
		assertOptsValidAndSQLEquals(t, opts, `CREATE STREAMLIT IF NOT EXISTS %s ROOT_LOCATION = '@test' MAIN_FILE = 'manifest.yml' QUERY_WAREHOUSE = %s COMMENT = 'test'`, id.FullyQualifiedName(), warehouse.FullyQualifiedName())
	})
}

func TestStreamlits_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterStreamlitOptions
	defaultOpts := func() *AlterStreamlitOptions {
		return &AlterStreamlitOptions{
			// adjusted manually
			IfExists: Bool(true),
			name:     id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterStreamlitOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.RenameTo] if set", func(t *testing.T) {
		opts := defaultOpts()
		opts.RenameTo = &emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.RenameTo opts.Set opts.Unset] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterStreamlitOptions", "RenameTo", "Set", "Unset"))
	})

	t.Run("validation: exactly one field from [opts.RenameTo opts.Set opts.Unset] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = new(StreamlitSet)
		opts.Unset = new(StreamlitUnset)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterStreamlitOptions", "RenameTo", "Set", "Unset"))
	})

	t.Run("validation: valid identifier for [opts.Set.QueryWarehouse] if set", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &StreamlitSet{
			QueryWarehouse: &emptyAccountObjectIdentifier,
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: at least one of the fields [opts.Set.RootLocation opts.Set.MainFile opts.Set.QueryWarehouse opts.Set.ExternalAccessIntegrations opts.Set.Comment opts.Set.Title] should be set", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = new(StreamlitSet)
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterStreamlitOptions.Set", "RootLocation", "MainFile", "QueryWarehouse", "ExternalAccessIntegrations", "Comment", "Title"))
	})

	t.Run("validation: at least one of the fields [opts.Unset.QueryWarehouse opts.Unset.Title opts.Unset.Comment] should be set", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = new(StreamlitUnset)
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterStreamlitOptions.Unset", "QueryWarehouse", "Title", "Comment"))
	})

	// all variants added manually
	t.Run("alter: set options", func(t *testing.T) {
		warehouse := NewAccountObjectIdentifier("test_warehouse")
		integration := NewAccountObjectIdentifier("integration")

		opts := defaultOpts()
		opts.Set = &StreamlitSet{
			RootLocation:               String("@test"),
			MainFile:                   String("manifest.yml"),
			QueryWarehouse:             &warehouse,
			ExternalAccessIntegrations: &ExternalAccessIntegrations{[]AccountObjectIdentifier{integration}},
			Comment:                    String("test"),
			Title:                      String("foo"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STREAMLIT IF EXISTS %s SET ROOT_LOCATION = '@test' MAIN_FILE = 'manifest.yml' QUERY_WAREHOUSE = %s EXTERNAL_ACCESS_INTEGRATIONS = ("integration") COMMENT = 'test' TITLE = 'foo'`, id.FullyQualifiedName(), warehouse.FullyQualifiedName())
	})

	t.Run("alter: unset options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &StreamlitUnset{
			QueryWarehouse: Pointer(true),
			Comment:        Pointer(true),
			Title:          Pointer(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER STREAMLIT IF EXISTS %s UNSET QUERY_WAREHOUSE, COMMENT, TITLE`, id.FullyQualifiedName())
	})

	t.Run("alter: rename", func(t *testing.T) {
		opts := defaultOpts()
		newId := randomSchemaObjectIdentifier()
		opts.RenameTo = &newId
		assertOptsValidAndSQLEquals(t, opts, `ALTER STREAMLIT IF EXISTS %s RENAME TO %s`, id.FullyQualifiedName(), newId.FullyQualifiedName())
	})
}

func TestStreamlits_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DropStreamlitOptions
	defaultOpts := func() *DropStreamlitOptions {
		return &DropStreamlitOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropStreamlitOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DROP STREAMLIT %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP STREAMLIT IF EXISTS %s`, id.FullyQualifiedName())
	})
}

func TestStreamlits_Show(t *testing.T) {
	// Minimal valid ShowStreamlitOptions
	defaultOpts := func() *ShowStreamlitOptions {
		return &ShowStreamlitOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowStreamlitOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "SHOW STREAMLITS")
	})

	// all variants added manually
	t.Run("show terse", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE STREAMLITS`)
	})

	t.Run("show with like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{
			Pattern: String("pattern"),
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STREAMLITS LIKE 'pattern'`)
	})

	t.Run("show with in", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{
			Account: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STREAMLITS IN ACCOUNT`)
	})

	t.Run("show with limit", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{
			Rows: Int(123),
			From: String("from pattern"),
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW STREAMLITS LIMIT 123 FROM 'from pattern'`)
	})
}

func TestStreamlits_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DescribeStreamlitOptions
	defaultOpts := func() *DescribeStreamlitOptions {
		return &DescribeStreamlitOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeStreamlitOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE STREAMLIT %s`, id.FullyQualifiedName())
	})

	// all options removed manually
}
