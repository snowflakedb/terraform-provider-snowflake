// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

// Added manually
const (
	glueAwsRoleArn         = "arn:aws:iam::123456789012:role/sqsAccess"
	glueCatalogId          = "123456789012"
	glueRegion             = "us-east-2"
	catalogNamespace       = "myNamespace"
	polarisCatalogUri      = "https://testorg-testacc.snowflakecomputing.com/polaris/api/catalog"
	restCatalogUri         = "https://api.tabular.io/ws"
	catalogName            = "my_catalog_name"
	sapBdcInvitationLink   = "https://example.hanacloud.ondemand.com/?code=123e4567-e89b-12d3-a456-426614174000"
	oAuthClientId          = "my_client_id"
	oAuthClientSecret      = "my_client_secret"
	oAuthAllowedScope      = "PRINCIPAL_ROLE:ALL"
	oAuthTokenUri          = "https://api.tabular.io/ws/v1/oauth/tokens"
	sigV4IamRole           = "arn:aws:iam::123456789012:role/my-role"
	sigV4SignignRegion     = "us-west-2"
	sigV4ExternalId        = "external_id"
	refreshIntervalSeconds = 60
	comment                = "test comment"
)

func TestCatalogIntegrations_Create(t *testing.T) {
	id := randomAccountObjectIdentifier()

	// Manually added default options for each type
	// Minimal valid CreateCatalogIntegrationOptions for AWS Glue
	defaultOptsAws := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			AwsGlueCatalogSourceParams: &AwsGlueParams{
				GlueAwsRoleArn: glueAwsRoleArn,
				GlueCatalogId:  glueCatalogId,
			},
			TableFormat: "ICEBERG",
			Enabled:     true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for object storage
	defaultOptsObjectStorage := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name:                             id,
			ObjectStorageCatalogSourceParams: new(ObjectStorageParams),
			TableFormat:                      "DELTA",
			Enabled:                          true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for Polaris
	defaultOptsPolaris := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			PolarisCatalogSourceParams: &PolarisParams{
				RestConfig: PolarisRestConfig{
					CatalogUri:  polarisCatalogUri,
					CatalogName: catalogName,
				},
				RestAuthentication: OAuthRestAuthentication{
					OauthClientId:      oAuthClientId,
					OauthClientSecret:  oAuthClientSecret,
					OauthAllowedScopes: []StringListItemWrapper{{Value: oAuthAllowedScope}},
				},
			},
			TableFormat: "ICEBERG",
			Enabled:     true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for Iceberg REST
	defaultOptsIcebergRest := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			IcebergRestCatalogSourceParams: &IcebergRestParams{
				RestConfig: IcebergRestRestConfig{
					CatalogUri: restCatalogUri,
				},
				SigV4RestAuthentication: &SigV4RestAuthentication{
					Sigv4IamRole: sigV4IamRole,
				},
			},
			TableFormat: "ICEBERG",
			Enabled:     true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for SAP Business Data Cloud
	defaultOptsSapBdc := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			SapBdcCatalogSourceParams: &SapBdcParams{
				RestConfig: SapBdcRestConfig{
					SapBdcInvitationLink: sapBdcInvitationLink,
				},
			},
			TableFormat: "DELTA",
			Enabled:     true,
		}
	}

	defaultOpts := defaultOptsAws

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.IfNotExists opts.OrReplace]", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfNotExists = Bool(true)
		opts.OrReplace = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateCatalogIntegrationOptions", "IfNotExists", "OrReplace"))
	})

	t.Run("validation: exactly one field from [opts.AwsGlueCatalogSourceParams opts.ObjectStorageCatalogSourceParams opts.PolarisCatalogSourceParams opts.IcebergRestCatalogSourceParams opts.SapBdcCatalogSourceParams] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.AwsGlueCatalogSourceParams = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions", "AwsGlueCatalogSourceParams", "ObjectStorageCatalogSourceParams", "PolarisCatalogSourceParams", "IcebergRestCatalogSourceParams", "SapBdcCatalogSourceParams"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.AwsGlueCatalogSourceParams opts.ObjectStorageCatalogSourceParams opts.PolarisCatalogSourceParams opts.IcebergRestCatalogSourceParams opts.SapBdcCatalogSourceParams] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		opts.AwsGlueCatalogSourceParams = new(AwsGlueParams)
		opts.ObjectStorageCatalogSourceParams = new(ObjectStorageParams)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions", "AwsGlueCatalogSourceParams", "ObjectStorageCatalogSourceParams", "PolarisCatalogSourceParams", "IcebergRestCatalogSourceParams", "SapBdcCatalogSourceParams"))
	})

	t.Run("validation: exactly one field from [opts.IcebergRestCatalogSourceParams.OAuthRestAuthentication opts.IcebergRestCatalogSourceParams.BearerRestAuthentication opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication] should be present", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions.IcebergRestCatalogSourceParams", "OAuthRestAuthentication", "BearerRestAuthentication", "SigV4RestAuthentication"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.IcebergRestCatalogSourceParams.OAuthRestAuthentication opts.IcebergRestCatalogSourceParams.BearerRestAuthentication opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication] should be present - more present", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = new(SigV4RestAuthentication)
		opts.IcebergRestCatalogSourceParams.BearerRestAuthentication = new(BearerRestAuthentication)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions.IcebergRestCatalogSourceParams", "OAuthRestAuthentication", "BearerRestAuthentication", "SigV4RestAuthentication"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s CATALOG_SOURCE = GLUE GLUE_AWS_ROLE_ARN = '%s' GLUE_CATALOG_ID = '%s' TABLE_FORMAT = ICEBERG ENABLED = true", id.FullyQualifiedName(), glueAwsRoleArn, glueCatalogId)
	})

	// Manually added all options for each variant
	t.Run("all options - AWS Glue", func(t *testing.T) {
		opts := defaultOptsAws()
		opts.IfNotExists = Bool(true)
		opts.AwsGlueCatalogSourceParams.GlueRegion = String(glueRegion)
		opts.AwsGlueCatalogSourceParams.CatalogNamespace = String(catalogNamespace)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(refreshIntervalSeconds)
		opts.Comment = String(comment)
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s CATALOG_SOURCE = GLUE "+
			"GLUE_AWS_ROLE_ARN = '%s' GLUE_CATALOG_ID = '%s' GLUE_REGION = '%s' CATALOG_NAMESPACE = '%s' "+
			"TABLE_FORMAT = ICEBERG ENABLED = false REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), glueAwsRoleArn, glueCatalogId, glueRegion, catalogNamespace, refreshIntervalSeconds, comment)
	})

	t.Run("all options - object storage", func(t *testing.T) {
		opts := defaultOptsObjectStorage()
		opts.IfNotExists = Bool(true)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(refreshIntervalSeconds)
		opts.Comment = String(comment)
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s CATALOG_SOURCE = OBJECT_STORE "+
			"TABLE_FORMAT = DELTA ENABLED = false REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), refreshIntervalSeconds, comment)
	})

	t.Run("all options - Polaris", func(t *testing.T) {
		opts := defaultOptsPolaris()
		opts.IfNotExists = Bool(true)
		opts.PolarisCatalogSourceParams.CatalogNamespace = String(catalogNamespace)
		opts.PolarisCatalogSourceParams.RestConfig.CatalogApiType = String("PUBLIC")
		opts.PolarisCatalogSourceParams.RestConfig.AccessDelegationMode = String("VENDED_CREDENTIALS")
		opts.PolarisCatalogSourceParams.RestAuthentication.OauthTokenUri = String(oAuthTokenUri)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(refreshIntervalSeconds)
		opts.Comment = String(comment)
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s CATALOG_SOURCE = POLARIS "+
			"CATALOG_NAMESPACE = '%s' REST_CONFIG = (CATALOG_URI = '%s' CATALOG_API_TYPE = PUBLIC CATALOG_NAME = '%s' ACCESS_DELEGATION_MODE = VENDED_CREDENTIALS) "+
			"REST_AUTHENTICATION = (TYPE = OAUTH OAUTH_TOKEN_URI = '%s' OAUTH_CLIENT_ID = '%s' OAUTH_CLIENT_SECRET = '%s' OAUTH_ALLOWED_SCOPES = ('%s')) "+
			"TABLE_FORMAT = ICEBERG ENABLED = false REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), catalogNamespace, polarisCatalogUri, catalogName, oAuthTokenUri, oAuthClientId, oAuthClientSecret, oAuthAllowedScope, refreshIntervalSeconds, comment)
	})

	t.Run("all options - Iceberg REST", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IfNotExists = Bool(true)
		opts.IcebergRestCatalogSourceParams.CatalogNamespace = String(catalogNamespace)
		opts.IcebergRestCatalogSourceParams.RestConfig.Prefix = String("prefix")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogName = String(catalogName)
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogApiType = String("AWS_API_GATEWAY")
		opts.IcebergRestCatalogSourceParams.RestConfig.AccessDelegationMode = String("VENDED_CREDENTIALS")
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication.Sigv4ExternalId = String(sigV4ExternalId)
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication.Sigv4SigningRegion = String(sigV4SignignRegion)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(refreshIntervalSeconds)
		opts.Comment = String(comment)
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s CATALOG_SOURCE = ICEBERG_REST "+
			"CATALOG_NAMESPACE = '%s' REST_CONFIG = (CATALOG_URI = '%s' PREFIX = 'prefix' CATALOG_NAME = '%s' CATALOG_API_TYPE = AWS_API_GATEWAY ACCESS_DELEGATION_MODE = VENDED_CREDENTIALS) "+
			"REST_AUTHENTICATION = (TYPE = SIGV4 SIGV4_IAM_ROLE = '%s' SIGV4_SIGNING_REGION = '%s' SIGV4_EXTERNAL_ID = '%s') "+
			"TABLE_FORMAT = ICEBERG ENABLED = false REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), catalogNamespace, restCatalogUri, catalogName, sigV4IamRole, sigV4SignignRegion, sigV4ExternalId, refreshIntervalSeconds, comment)
	})

	t.Run("all options - SAP Business Data Cloud", func(t *testing.T) {
		opts := defaultOptsSapBdc()
		opts.IfNotExists = Bool(true)
		opts.SapBdcCatalogSourceParams.RestConfig.AccessDelegationMode = String("VENDED_CREDENTIALS")
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(refreshIntervalSeconds)
		opts.Comment = String(comment)
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s CATALOG_SOURCE = SAP_BDC "+
			"REST_CONFIG = (SAP_BDC_INVITATION_LINK = '%s' ACCESS_DELEGATION_MODE = VENDED_CREDENTIALS) "+
			"TABLE_FORMAT = DELTA ENABLED = false REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), sapBdcInvitationLink, refreshIntervalSeconds, comment)
	})
}

func TestCatalogIntegrations_Alter(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid AlterCatalogIntegrationOptions
	defaultOpts := func() *AlterCatalogIntegrationOptions {
		return &AlterCatalogIntegrationOptions{
			name: id,
			Set: &CatalogIntegrationSet{
				Enabled: Bool(true),
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.Set opts.SetTags opts.UnsetTags] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterCatalogIntegrationOptions", "Set", "SetTags", "UnsetTags"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.Set opts.SetTags opts.UnsetTags] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		opts.SetTags = []TagAssociation{{Name: NewAccountObjectIdentifier("tag1"), Value: "tag_value"}}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterCatalogIntegrationOptions", "Set", "SetTags", "UnsetTags"))
	})

	t.Run("validation: conflicting fields for [opts.Set.OAuthRestAuthentication opts.Set.BearerRestAuthentication]", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &CatalogIntegrationSet{
			SetOAuthRestAuthentication: &SetOAuthRestAuthentication{
				OauthClientSecret: oAuthClientSecret,
			},
			SetBearerRestAuthentication: &SetBearerRestAuthentication{
				BearerToken: "test-token",
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterCatalogIntegrationOptions.Set", "SetOAuthRestAuthentication", "SetBearerRestAuthentication"))
	})

	t.Run("validation: at least one of the fields [opts.Set.SetOAuthRestAuthentication opts.Set.SetBearerRestAuthentication opts.Set.Enabled opts.Set.RefreshIntervalSeconds opts.Set.Comment] should be set", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = new(CatalogIntegrationSet)
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterCatalogIntegrationOptions.Set", "SetOAuthRestAuthentication", "SetBearerRestAuthentication", "Enabled", "RefreshIntervalSeconds", "Comment"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "ALTER CATALOG INTEGRATION %s SET ENABLED = true", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &CatalogIntegrationSet{
			SetBearerRestAuthentication: &SetBearerRestAuthentication{
				BearerToken: "test-token",
			},
			Enabled:                Bool(true),
			RefreshIntervalSeconds: Int(refreshIntervalSeconds),
			Comment:                &StringAllowEmpty{Value: comment},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER CATALOG INTEGRATION IF EXISTS %s SET "+
			"REST_AUTHENTICATION = (BEARER_TOKEN = 'test-token') ENABLED = true REFRESH_INTERVAL_SECONDS = %d COMMENT = '%s'",
			id.FullyQualifiedName(), refreshIntervalSeconds, comment)
	})
}

func TestCatalogIntegrations_Drop(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid DropCatalogIntegrationOptions
	defaultOpts := func() *DropCatalogIntegrationOptions {
		return &DropCatalogIntegrationOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DROP CATALOG INTEGRATION %s", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, "DROP CATALOG INTEGRATION IF EXISTS %s", id.FullyQualifiedName())
	})
}

func TestCatalogIntegrations_Show(t *testing.T) {
	// Minimal valid ShowCatalogIntegrationOptions
	defaultOpts := func() *ShowCatalogIntegrationOptions {
		return &ShowCatalogIntegrationOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "SHOW CATALOG INTEGRATIONS")
	})

	t.Run("show like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("like-pattern")}
		assertOptsValidAndSQLEquals(t, opts, "SHOW CATALOG INTEGRATIONS LIKE 'like-pattern'")
	})
}

func TestCatalogIntegrations_Describe(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid DescribeCatalogIntegrationOptions
	defaultOpts := func() *DescribeCatalogIntegrationOptions {
		return &DescribeCatalogIntegrationOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DESCRIBE CATALOG INTEGRATION %s", id.FullyQualifiedName())
	})

	// all options removed manually
}
