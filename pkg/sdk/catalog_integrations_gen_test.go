// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

// Added manually
const (
	glueAwsRoleArn       = "arn:aws:iam::123456789012:role/sqsAccess"
	glueCatalogId        = "123456789012"
	glueRegion           = "us-east-2"
	polarisCatalogUri    = "https://testorg-testacc.snowflakecomputing.com/polaris/api/catalog"
	restCatalogUri       = "https://api.tabular.io/ws"
	sapBdcInvitationLink = "https://example.hanacloud.ondemand.com/?code=123e4567-e89b-12d3-a456-426614174000"
	oAuthClientId        = "my_client_id"
	oAuthClientSecret    = "my_client_secret"
	oAuthAllowedScope    = "PRINCIPAL_ROLE:ALL"
	oAuthTokenUri        = "https://api.tabular.io/ws/v1/oauth/tokens"
	sigV4IamRole         = "arn:aws:iam::123456789012:role/my-role"
	sigV4SigningRegion   = "us-west-2"
	sigV4ExternalId      = "external_id"
)

func TestCatalogIntegrations_Create(t *testing.T) {
	id := randomAccountObjectIdentifier()

	// Manually added default options for each type
	// Minimal valid CreateCatalogIntegrationOptions for AWS Glue
	defaultOptsAws := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			AwsGlueCatalogSourceParams: &AwsGlueParams{
				GlueAwsRoleArn: glueAwsRoleArn,
				GlueCatalogId:  glueCatalogId,
			},
			Enabled: true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for object storage
	defaultOptsObjectStorage := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			ObjectStorageCatalogSourceParams: &ObjectStorageParams{
				TableFormat: CatalogIntegrationTableFormatDelta,
			},
			Enabled: true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for Open Catalog
	defaultOptsOpenCatalog := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			OpenCatalogCatalogSourceParams: &OpenCatalogParams{
				RestConfig: OpenCatalogRestConfig{
					CatalogUri:  polarisCatalogUri,
					CatalogName: "my_catalog_name",
				},
				RestAuthentication: OAuthRestAuthentication{
					OauthClientId:      oAuthClientId,
					OauthClientSecret:  oAuthClientSecret,
					OauthAllowedScopes: []StringListItemWrapper{{Value: oAuthAllowedScope}},
				},
			},
			Enabled: true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for Iceberg REST
	defaultOptsIcebergRest := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			IcebergRestCatalogSourceParams: &IcebergRestParams{
				RestConfig: IcebergRestRestConfig{
					CatalogUri: restCatalogUri,
				},
				SigV4RestAuthentication: &SigV4RestAuthentication{
					Sigv4IamRole: sigV4IamRole,
				},
			},
			Enabled: true,
		}
	}

	// Minimal valid CreateCatalogIntegrationOptions for SAP Business Data Cloud
	defaultOptsSapBdc := func() *CreateCatalogIntegrationOptions {
		return &CreateCatalogIntegrationOptions{
			name: id,
			SapBdcCatalogSourceParams: &SapBdcParams{
				RestConfig: SapBdcRestConfig{
					SapBdcInvitationLink: sapBdcInvitationLink,
				},
			},
			Enabled: true,
		}
	}

	defaultOpts := defaultOptsAws

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.IfNotExists opts.OrReplace]", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfNotExists = Bool(true)
		opts.OrReplace = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateCatalogIntegrationOptions", "IfNotExists", "OrReplace"))
	})

	t.Run("validation: exactly one field from [opts.AwsGlueCatalogSourceParams opts.ObjectStorageCatalogSourceParams opts.OpenCatalogCatalogSourceParams opts.IcebergRestCatalogSourceParams opts.SapBdcCatalogSourceParams] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.AwsGlueCatalogSourceParams = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions", "AwsGlueCatalogSourceParams", "ObjectStorageCatalogSourceParams", "OpenCatalogCatalogSourceParams", "IcebergRestCatalogSourceParams", "SapBdcCatalogSourceParams"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.AwsGlueCatalogSourceParams opts.ObjectStorageCatalogSourceParams opts.OpenCatalogCatalogSourceParams opts.IcebergRestCatalogSourceParams opts.SapBdcCatalogSourceParams] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		opts.AwsGlueCatalogSourceParams = new(AwsGlueParams)
		opts.ObjectStorageCatalogSourceParams = new(ObjectStorageParams)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions", "AwsGlueCatalogSourceParams", "ObjectStorageCatalogSourceParams", "OpenCatalogCatalogSourceParams", "IcebergRestCatalogSourceParams", "SapBdcCatalogSourceParams"))
	})

	t.Run("validation: exactly one field from [opts.IcebergRestCatalogSourceParams.OAuthRestAuthentication opts.IcebergRestCatalogSourceParams.BearerRestAuthentication opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication] should be present", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions.IcebergRestCatalogSourceParams", "OAuthRestAuthentication", "BearerRestAuthentication", "SigV4RestAuthentication"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.IcebergRestCatalogSourceParams.OAuthRestAuthentication opts.IcebergRestCatalogSourceParams.BearerRestAuthentication opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication] should be present - more present", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = new(SigV4RestAuthentication)
		opts.IcebergRestCatalogSourceParams.BearerRestAuthentication = new(BearerRestAuthentication)
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("CreateCatalogIntegrationOptions.IcebergRestCatalogSourceParams", "OAuthRestAuthentication", "BearerRestAuthentication", "SigV4RestAuthentication"))
	})

	// Manually added basic for each variant
	t.Run("basic - AWS GLue", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s CATALOG_SOURCE = GLUE TABLE_FORMAT = ICEBERG GLUE_AWS_ROLE_ARN = '%s' GLUE_CATALOG_ID = '%s' ENABLED = true", id.FullyQualifiedName(), glueAwsRoleArn, glueCatalogId)
	})

	t.Run("basic - object storage", func(t *testing.T) {
		opts := defaultOptsObjectStorage()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s CATALOG_SOURCE = OBJECT_STORE TABLE_FORMAT = DELTA ENABLED = true", id.FullyQualifiedName())
	})

	t.Run("basic - Open Catalog", func(t *testing.T) {
		opts := defaultOptsOpenCatalog()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s "+
			"CATALOG_SOURCE = POLARIS "+
			"TABLE_FORMAT = ICEBERG "+
			"REST_CONFIG = (CATALOG_URI = '%s' CATALOG_NAME = 'my_catalog_name') "+
			"REST_AUTHENTICATION = (TYPE = OAUTH OAUTH_CLIENT_ID = '%s' OAUTH_CLIENT_SECRET = '%s' OAUTH_ALLOWED_SCOPES = ('%s')) "+
			"ENABLED = true",
			id.FullyQualifiedName(), polarisCatalogUri, oAuthClientId, oAuthClientSecret, oAuthAllowedScope)
	})

	t.Run("basic - Iceberg REST", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s "+
			"CATALOG_SOURCE = ICEBERG_REST "+
			"TABLE_FORMAT = ICEBERG "+
			"REST_CONFIG = (CATALOG_URI = '%s') "+
			"REST_AUTHENTICATION = (TYPE = SIGV4 SIGV4_IAM_ROLE = '%s') "+
			"ENABLED = true",
			id.FullyQualifiedName(), restCatalogUri, sigV4IamRole)
	})

	t.Run("basic - SAP Business Data Cloud", func(t *testing.T) {
		opts := defaultOptsSapBdc()
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION %s "+
			"CATALOG_SOURCE = SAP_BDC "+
			"TABLE_FORMAT = DELTA "+
			"REST_CONFIG = (SAP_BDC_INVITATION_LINK = '%s') "+
			"ENABLED = true",
			id.FullyQualifiedName(), sapBdcInvitationLink)
	})

	// Manually added all options for each variant
	t.Run("all options - AWS Glue", func(t *testing.T) {
		opts := defaultOptsAws()
		opts.IfNotExists = Bool(true)
		opts.AwsGlueCatalogSourceParams.GlueRegion = String(glueRegion)
		opts.AwsGlueCatalogSourceParams.CatalogNamespace = String("myNamespace")
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = GLUE "+
			"TABLE_FORMAT = ICEBERG "+
			"GLUE_AWS_ROLE_ARN = '%s' "+
			"GLUE_CATALOG_ID = '%s' "+
			"GLUE_REGION = '%s' "+
			"CATALOG_NAMESPACE = 'myNamespace' "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), glueAwsRoleArn, glueCatalogId, glueRegion)
	})

	t.Run("all options - object storage", func(t *testing.T) {
		opts := defaultOptsObjectStorage()
		opts.IfNotExists = Bool(true)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = OBJECT_STORE "+
			"TABLE_FORMAT = DELTA "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName())
	})

	t.Run("all options - Open Catalog", func(t *testing.T) {
		opts := defaultOptsOpenCatalog()
		opts.IfNotExists = Bool(true)
		opts.OpenCatalogCatalogSourceParams.CatalogNamespace = String("myNamespace")
		opts.OpenCatalogCatalogSourceParams.RestConfig.CatalogApiType = Pointer(CatalogIntegrationCatalogApiTypePublic)
		opts.OpenCatalogCatalogSourceParams.RestConfig.AccessDelegationMode = Pointer(CatalogIntegrationAccessDelegationModeVendedCredentials)
		opts.OpenCatalogCatalogSourceParams.RestAuthentication.OauthTokenUri = String(oAuthTokenUri)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = POLARIS "+
			"TABLE_FORMAT = ICEBERG "+
			"CATALOG_NAMESPACE = 'myNamespace' "+
			"REST_CONFIG = (CATALOG_URI = '%s' CATALOG_API_TYPE = %s CATALOG_NAME = 'my_catalog_name' ACCESS_DELEGATION_MODE = %s) "+
			"REST_AUTHENTICATION = (TYPE = OAUTH OAUTH_TOKEN_URI = '%s' OAUTH_CLIENT_ID = '%s' OAUTH_CLIENT_SECRET = '%s' OAUTH_ALLOWED_SCOPES = ('%s')) "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), polarisCatalogUri, CatalogIntegrationCatalogApiTypePublic, CatalogIntegrationAccessDelegationModeVendedCredentials, oAuthTokenUri, oAuthClientId, oAuthClientSecret, oAuthAllowedScope)
	})

	t.Run("all options - Iceberg REST with SigV4", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IfNotExists = Bool(true)
		opts.IcebergRestCatalogSourceParams.CatalogNamespace = String("myNamespace")
		opts.IcebergRestCatalogSourceParams.RestConfig.Prefix = String("prefix")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogName = String("my_catalog_name")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogApiType = Pointer(CatalogIntegrationCatalogApiTypeAwsApiGateway)
		opts.IcebergRestCatalogSourceParams.RestConfig.AccessDelegationMode = Pointer(CatalogIntegrationAccessDelegationModeVendedCredentials)
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication.Sigv4ExternalId = String(sigV4ExternalId)
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication.Sigv4SigningRegion = String(sigV4SigningRegion)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = ICEBERG_REST "+
			"TABLE_FORMAT = ICEBERG "+
			"CATALOG_NAMESPACE = 'myNamespace' "+
			"REST_CONFIG = (CATALOG_URI = '%s' PREFIX = 'prefix' CATALOG_NAME = 'my_catalog_name' CATALOG_API_TYPE = %s ACCESS_DELEGATION_MODE = %s) "+
			"REST_AUTHENTICATION = (TYPE = SIGV4 SIGV4_IAM_ROLE = '%s' SIGV4_SIGNING_REGION = '%s' SIGV4_EXTERNAL_ID = '%s') "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), restCatalogUri, CatalogIntegrationCatalogApiTypeAwsApiGateway, CatalogIntegrationAccessDelegationModeVendedCredentials, sigV4IamRole, sigV4SigningRegion, sigV4ExternalId)
	})

	t.Run("all options - Iceberg REST with OAuth", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IfNotExists = Bool(true)
		opts.IcebergRestCatalogSourceParams.CatalogNamespace = String("myNamespace")
		opts.IcebergRestCatalogSourceParams.RestConfig.Prefix = String("prefix")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogName = String("my_catalog_name")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogApiType = Pointer(CatalogIntegrationCatalogApiTypeAwsApiGateway)
		opts.IcebergRestCatalogSourceParams.RestConfig.AccessDelegationMode = Pointer(CatalogIntegrationAccessDelegationModeVendedCredentials)
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = nil
		opts.IcebergRestCatalogSourceParams.OAuthRestAuthentication = &OAuthRestAuthentication{
			OauthClientId:      oAuthClientId,
			OauthClientSecret:  oAuthClientSecret,
			OauthAllowedScopes: []StringListItemWrapper{{Value: oAuthAllowedScope}},
		}
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = ICEBERG_REST "+
			"TABLE_FORMAT = ICEBERG "+
			"CATALOG_NAMESPACE = 'myNamespace' "+
			"REST_CONFIG = (CATALOG_URI = '%s' PREFIX = 'prefix' CATALOG_NAME = 'my_catalog_name' CATALOG_API_TYPE = %s ACCESS_DELEGATION_MODE = %s) "+
			"REST_AUTHENTICATION = (TYPE = OAUTH OAUTH_CLIENT_ID = '%s' OAUTH_CLIENT_SECRET = '%s' OAUTH_ALLOWED_SCOPES = ('%s')) "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), restCatalogUri, CatalogIntegrationCatalogApiTypeAwsApiGateway, CatalogIntegrationAccessDelegationModeVendedCredentials, oAuthClientId, oAuthClientSecret, oAuthAllowedScope)
	})

	t.Run("all options - Iceberg REST with bearer token", func(t *testing.T) {
		opts := defaultOptsIcebergRest()
		opts.IfNotExists = Bool(true)
		opts.IcebergRestCatalogSourceParams.CatalogNamespace = String("myNamespace")
		opts.IcebergRestCatalogSourceParams.RestConfig.Prefix = String("prefix")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogName = String("my_catalog_name")
		opts.IcebergRestCatalogSourceParams.RestConfig.CatalogApiType = Pointer(CatalogIntegrationCatalogApiTypeAwsApiGateway)
		opts.IcebergRestCatalogSourceParams.RestConfig.AccessDelegationMode = Pointer(CatalogIntegrationAccessDelegationModeVendedCredentials)
		opts.IcebergRestCatalogSourceParams.SigV4RestAuthentication = nil
		opts.IcebergRestCatalogSourceParams.BearerRestAuthentication = &BearerRestAuthentication{
			BearerToken: "test-token",
		}
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = ICEBERG_REST "+
			"TABLE_FORMAT = ICEBERG "+
			"CATALOG_NAMESPACE = 'myNamespace' "+
			"REST_CONFIG = (CATALOG_URI = '%s' PREFIX = 'prefix' CATALOG_NAME = 'my_catalog_name' CATALOG_API_TYPE = %s ACCESS_DELEGATION_MODE = %s) "+
			"REST_AUTHENTICATION = (TYPE = BEARER BEARER_TOKEN = 'test-token') "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), restCatalogUri, CatalogIntegrationCatalogApiTypeAwsApiGateway, CatalogIntegrationAccessDelegationModeVendedCredentials)
	})

	t.Run("all options - SAP Business Data Cloud", func(t *testing.T) {
		opts := defaultOptsSapBdc()
		opts.IfNotExists = Bool(true)
		opts.SapBdcCatalogSourceParams.RestConfig.AccessDelegationMode = Pointer(CatalogIntegrationAccessDelegationModeVendedCredentials)
		opts.Enabled = false
		opts.RefreshIntervalSeconds = Int(60)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, "CREATE CATALOG INTEGRATION IF NOT EXISTS %s "+
			"CATALOG_SOURCE = SAP_BDC "+
			"TABLE_FORMAT = DELTA "+
			"REST_CONFIG = (SAP_BDC_INVITATION_LINK = '%s' ACCESS_DELEGATION_MODE = VENDED_CREDENTIALS) "+
			"ENABLED = false "+
			"REFRESH_INTERVAL_SECONDS = 60 "+
			"COMMENT = 'test comment'",
			id.FullyQualifiedName(), sapBdcInvitationLink)
	})
}

func TestCatalogIntegrations_Alter(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid AlterCatalogIntegrationOptions
	defaultOpts := func() *AlterCatalogIntegrationOptions {
		return &AlterCatalogIntegrationOptions{
			name: id,
			Set: &CatalogIntegrationSet{
				Enabled: Bool(true),
			},
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.Set opts.SetTags opts.UnsetTags] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = nil
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterCatalogIntegrationOptions", "Set", "SetTags", "UnsetTags"))
	})

	// variant added manually
	t.Run("validation: exactly one field from [opts.Set opts.SetTags opts.UnsetTags] should be present - more present", func(t *testing.T) {
		opts := defaultOpts()
		opts.SetTags = []TagAssociation{{Name: NewAccountObjectIdentifier("tag1"), Value: "tag_value"}}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterCatalogIntegrationOptions", "Set", "SetTags", "UnsetTags"))
	})

	t.Run("validation: conflicting fields for [opts.Set.OAuthRestAuthentication opts.Set.BearerRestAuthentication]", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &CatalogIntegrationSet{
			SetOAuthRestAuthentication: &SetOAuthRestAuthentication{
				OauthClientSecret: oAuthClientSecret,
			},
			SetBearerRestAuthentication: &SetBearerRestAuthentication{
				BearerToken: "test-token",
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterCatalogIntegrationOptions.Set", "SetOAuthRestAuthentication", "SetBearerRestAuthentication"))
	})

	t.Run("validation: at least one of the fields [opts.Set.SetOAuthRestAuthentication opts.Set.SetBearerRestAuthentication opts.Set.Enabled opts.Set.RefreshIntervalSeconds opts.Set.Comment] should be set", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = new(CatalogIntegrationSet)
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterCatalogIntegrationOptions.Set", "SetOAuthRestAuthentication", "SetBearerRestAuthentication", "Enabled", "RefreshIntervalSeconds", "Comment"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "ALTER CATALOG INTEGRATION %s SET ENABLED = true", id.FullyQualifiedName())
	})

	// Manually added all options for each allowed authentication type
	t.Run("all options - Bearer token", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &CatalogIntegrationSet{
			SetBearerRestAuthentication: &SetBearerRestAuthentication{
				BearerToken: "test-token",
			},
			Enabled:                Bool(true),
			RefreshIntervalSeconds: Int(60),
			Comment:                &StringAllowEmpty{Value: "test comment"},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER CATALOG INTEGRATION IF EXISTS %s SET "+
			"REST_AUTHENTICATION = (BEARER_TOKEN = 'test-token') "+
			"ENABLED = true "+
			"REFRESH_INTERVAL_SECONDS = %d "+
			"COMMENT = '%s'",
			id.FullyQualifiedName(), 60, "test comment")
	})

	t.Run("all options - OAuth", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &CatalogIntegrationSet{
			SetOAuthRestAuthentication: &SetOAuthRestAuthentication{
				OauthClientSecret: oAuthClientSecret,
			},
			Enabled:                Bool(true),
			RefreshIntervalSeconds: Int(60),
			Comment:                &StringAllowEmpty{Value: "test comment"},
		}
		assertOptsValidAndSQLEquals(t, opts, "ALTER CATALOG INTEGRATION IF EXISTS %s SET "+
			"REST_AUTHENTICATION = (OAUTH_CLIENT_SECRET = '%s') "+
			"ENABLED = true "+
			"REFRESH_INTERVAL_SECONDS = %d "+
			"COMMENT = '%s'",
			id.FullyQualifiedName(), oAuthClientSecret, 60, "test comment")
	})
}

func TestCatalogIntegrations_Drop(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid DropCatalogIntegrationOptions
	defaultOpts := func() *DropCatalogIntegrationOptions {
		return &DropCatalogIntegrationOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DROP CATALOG INTEGRATION %s", id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, "DROP CATALOG INTEGRATION IF EXISTS %s", id.FullyQualifiedName())
	})
}

func TestCatalogIntegrations_Show(t *testing.T) {
	// Minimal valid ShowCatalogIntegrationOptions
	defaultOpts := func() *ShowCatalogIntegrationOptions {
		return &ShowCatalogIntegrationOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "SHOW CATALOG INTEGRATIONS")
	})

	t.Run("show like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("like-pattern")}
		assertOptsValidAndSQLEquals(t, opts, "SHOW CATALOG INTEGRATIONS LIKE 'like-pattern'")
	})
}

func TestCatalogIntegrations_Describe(t *testing.T) {
	id := randomAccountObjectIdentifier()
	// Minimal valid DescribeCatalogIntegrationOptions
	defaultOpts := func() *DescribeCatalogIntegrationOptions {
		return &DescribeCatalogIntegrationOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeCatalogIntegrationOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptyAccountObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, "DESCRIBE CATALOG INTEGRATION %s", id.FullyQualifiedName())
	})

	// all options removed manually
}
