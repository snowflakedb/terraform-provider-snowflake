// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

func TestHybridTables_Create(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateHybridTableOptions
	defaultOpts := func() *CreateHybridTableOptions {
		return &CreateHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateHybridTableOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		opts.DataRetentionTimeInDays = Int(7)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE HYBRID TABLE %s DATA_RETENTION_TIME_IN_DAYS = 7 COMMENT = 'test comment'`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterHybridTableOptions
	defaultOpts := func() *AlterHybridTableOptions {
		return &AlterHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.ConstraintAction opts.AlterColumnAction opts.DropColumnAction opts.DropIndexAction opts.Set opts.Unset] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions", "ConstraintAction", "AlterColumnAction", "DropColumnAction", "DropIndexAction", "Set", "Unset"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{
			Comment: String("new comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s SET COMMENT = 'new comment'`, id.FullyQualifiedName())
	})

	t.Run("all options - set", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays: Int(14),
			Comment:                 String("updated comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s SET DATA_RETENTION_TIME_IN_DAYS = 14 COMMENT = 'updated comment'`, id.FullyQualifiedName())
	})

	t.Run("all options - unset", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays: Bool(true),
			Comment:                 Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s UNSET DATA_RETENTION_TIME_IN_DAYS COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: column set comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName: "column1",
			Comment:    String("column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN column1 COMMENT 'column comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: column unset comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName:   "column1",
			UnsetComment: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN column1 UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: drop column", func(t *testing.T) {
		opts := defaultOpts()
		opts.DropColumnAction = &HybridTableDropColumnAction{
			ColumnName: "column_to_drop",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP COLUMN column_to_drop`, id.FullyQualifiedName())
	})

	t.Run("alter: drop index", func(t *testing.T) {
		opts := defaultOpts()
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IndexName: "idx_name",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP INDEX idx_name`, id.FullyQualifiedName())
	})

	t.Run("alter: add constraint unique", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Add: &HybridTableConstraintActionAdd{
				OutOfLineConstraint: HybridTableOutOfLineConstraint{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"col1", "col2"},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ADD UNIQUE (col1, col2)`, id.FullyQualifiedName())
	})

	t.Run("alter: drop constraint by name", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ConstraintName: String("constraint_name"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP CONSTRAINT constraint_name`, id.FullyQualifiedName())
	})

	t.Run("alter: drop constraint by type", func(t *testing.T) {
		opts := defaultOpts()
		constraintType := ColumnConstraintTypeUnique
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ColumnConstraintType: &constraintType,
				Columns:              []string{"col1"},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP UNIQUE (col1)`, id.FullyQualifiedName())
	})

	t.Run("alter: rename constraint", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Rename: &HybridTableConstraintActionRename{
				OldName: "old_constraint_name",
				NewName: "new_constraint_name",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RENAME CONSTRAINT old_constraint_name TO new_constraint_name`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DropHybridTableOptions
	defaultOpts := func() *DropHybridTableOptions {
		return &DropHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s RESTRICT`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Show(t *testing.T) {
	// Minimal valid ShowHybridTableOptions
	defaultOpts := func() *ShowHybridTableOptions {
		return &ShowHybridTableOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		opts.Like = &Like{Pattern: String("some_pattern")}
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("db", "schema")}
		opts.StartsWith = String("prefix")
		opts.Limit = &LimitFrom{Rows: Int(10)}
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE HYBRID TABLES LIKE 'some_pattern' IN SCHEMA "db"."schema" STARTS WITH 'prefix' LIMIT 10`)
	})

	t.Run("show with in database", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Database: NewAccountObjectIdentifier("test_db")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN DATABASE "test_db"`)
	})

	t.Run("show with in schema", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("test_db", "test_schema")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN SCHEMA "test_db"."test_schema"`)
	})

	t.Run("show with like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("pattern_test")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIKE 'pattern_test'`)
	})

	t.Run("show with limit", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{Rows: Int(10), From: String("table_name")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIMIT 10 FROM 'table_name'`)
	})
}

func TestHybridTables_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DescribeHybridTableOptions
	defaultOpts := func() *DescribeHybridTableOptions {
		return &DescribeHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE TABLE %s`, id.FullyQualifiedName())
	})
}
