// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

func TestHybridTables_Create(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateHybridTableOptions
	defaultOpts := func() *CreateHybridTableOptions {
		return &CreateHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateHybridTableOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("create", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		opts.DataRetentionTimeInDays = Int(7)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE HYBRID TABLE %s DATA_RETENTION_TIME_IN_DAYS = 7 COMMENT = 'test comment'`, id.FullyQualifiedName())
	})

	t.Run("with columns and constraints", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{
			Columns: []HybridTableColumn{
				{
					Name: "ID",
					Type: DataTypeNumber,
					InlineConstraint: &HybridTableColumnInlineConstraint{
						Type: ColumnConstraintTypePrimaryKey,
					},
				},
				{
					Name:    "NAME",
					Type:    DataTypeVARCHAR,
					NotNull: Bool(true),
					Comment: String("the name"),
				},
			},
			OutOfLineConstraint: []HybridTableOutOfLineConstraint{
				{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"NAME"},
				},
			},
			OutOfLineIndex: []HybridTableOutOfLineIndex{
				{
					Name:    "idx_name",
					Columns: []string{"NAME"},
				},
			},
		}
		opts.DataRetentionTimeInDays = Int(7)
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s (ID NUMBER PRIMARY KEY, NAME VARCHAR NOT NULL COMMENT 'the name', UNIQUE (NAME), INDEX idx_name (NAME)) DATA_RETENTION_TIME_IN_DAYS = 7`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterHybridTableOptions
	defaultOpts := func() *AlterHybridTableOptions {
		return &AlterHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.NewName opts.AddColumnAction opts.ConstraintAction opts.AlterColumnAction opts.ModifyColumnAction opts.DropColumnAction opts.DropIndexAction opts.Set opts.Unset] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions", "NewName", "AddColumnAction", "ConstraintAction", "AlterColumnAction", "ModifyColumnAction", "DropColumnAction", "DropIndexAction", "Set", "Unset"))
	})

	t.Run("validation: constraint action - exactly one of Add, Drop, Rename required", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("HybridTableConstraintAction", "Add", "Drop", "Rename"))
	})

	t.Run("validation: drop constraint - exactly one constraint type required", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("HybridTableConstraintActionDrop", "ConstraintName", "PrimaryKey", "Unique", "ForeignKey"))
	})

	t.Run("validation: drop constraint - cascade and restrict are mutually exclusive", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				PrimaryKey: Bool(true),
				Cascade:    Bool(true),
				Restrict:   Bool(true),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("HybridTableConstraintActionDrop", "Cascade", "Restrict"))
	})

	t.Run("validation: at least one of set fields", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{}
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("HybridTableSetProperties", "DataRetentionTimeInDays", "MaxDataExtensionTimeInDays", "ChangeTracking", "DefaultDdlCollation", "EnableSchemaEvolution", "Comment"))
	})

	t.Run("validation: at least one of unset fields", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &HybridTableUnsetProperties{}
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("HybridTableUnsetProperties", "DataRetentionTimeInDays", "MaxDataExtensionTimeInDays", "ChangeTracking", "DefaultDdlCollation", "EnableSchemaEvolution", "Comment"))
	})

	t.Run("validation: alter column - conflicting fields for [opts.Comment opts.UnsetComment]", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName:   "column1",
			Comment:      String("comment"),
			UnsetComment: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("HybridTableAlterColumnAction", "Comment", "UnsetComment"))
	})

	t.Run("validation: modify column - conflicting fields for [opts.Comment opts.UnsetComment]", func(t *testing.T) {
		opts := defaultOpts()
		opts.ModifyColumnAction = &HybridTableModifyColumnAction{
			ColumnName:   "column1",
			Comment:      String("comment"),
			UnsetComment: Bool(true),
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("HybridTableModifyColumnAction", "Comment", "UnsetComment"))
	})

	t.Run("alter: set", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays:    Int(14),
			MaxDataExtensionTimeInDays: Int(28),
			ChangeTracking:             Bool(true),
			DefaultDdlCollation:        String("en-ci"),
			EnableSchemaEvolution:      Bool(true),
			Comment:                    String("updated comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s SET DATA_RETENTION_TIME_IN_DAYS = 14 MAX_DATA_EXTENSION_TIME_IN_DAYS = 28 CHANGE_TRACKING = true DEFAULT_DDL_COLLATION = 'en-ci' ENABLE_SCHEMA_EVOLUTION = true COMMENT = 'updated comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: unset", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays:    Bool(true),
			MaxDataExtensionTimeInDays: Bool(true),
			ChangeTracking:             Bool(true),
			DefaultDdlCollation:        Bool(true),
			EnableSchemaEvolution:      Bool(true),
			Comment:                    Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s UNSET DATA_RETENTION_TIME_IN_DAYS MAX_DATA_EXTENSION_TIME_IN_DAYS CHANGE_TRACKING DEFAULT_DDL_COLLATION ENABLE_SCHEMA_EVOLUTION COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column set comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName: "column1",
			Comment:    String("column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ALTER COLUMN column1 COMMENT 'column comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column unset comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName:   "column1",
			UnsetComment: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ALTER COLUMN column1 UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: modify column set comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ModifyColumnAction = &HybridTableModifyColumnAction{
			ColumnName: "column1",
			Comment:    String("column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s MODIFY COLUMN column1 COMMENT 'column comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: modify column unset comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ModifyColumnAction = &HybridTableModifyColumnAction{
			ColumnName:   "column1",
			UnsetComment: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s MODIFY COLUMN column1 UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: drop column", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.DropColumnAction = &HybridTableDropColumnAction{
			Columns: []string{"column_to_drop"},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP COLUMN column_to_drop`, id.FullyQualifiedName())
	})

	t.Run("alter: drop index", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IndexName: "idx_name",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP INDEX idx_name`, id.FullyQualifiedName())
	})

	t.Run("alter: add constraint", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Add: &HybridTableConstraintActionAdd{
				OutOfLineConstraint: HybridTableOutOfLineConstraint{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"col1", "col2"},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ADD UNIQUE (col1, col2)`, id.FullyQualifiedName())
	})

	t.Run("alter: drop constraint by name", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ConstraintName: String("my_constraint"),
				Restrict:       Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP CONSTRAINT my_constraint RESTRICT`, id.FullyQualifiedName())
	})

	t.Run("alter: drop primary key", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				PrimaryKey: Bool(true),
				Cascade:    Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP PRIMARY KEY CASCADE`, id.FullyQualifiedName())
	})

	t.Run("alter: drop unique with columns", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				Unique:  Bool(true),
				Columns: []string{"col1"},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP UNIQUE (col1)`, id.FullyQualifiedName())
	})

	t.Run("alter: drop foreign key with cascade", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ForeignKey: Bool(true),
				Columns:    []string{"col1", "col2"},
				Cascade:    Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP FOREIGN KEY (col1, col2) CASCADE`, id.FullyQualifiedName())
	})

	t.Run("alter: rename constraint", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Rename: &HybridTableConstraintActionRename{
				OldName: "old_constraint_name",
				NewName: "new_constraint_name",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s RENAME CONSTRAINT old_constraint_name TO new_constraint_name`, id.FullyQualifiedName())
	})

	t.Run("alter: rename to", func(t *testing.T) {
		newID := randomSchemaObjectIdentifierInSchema(id.SchemaId())
		opts := defaultOpts()
		opts.NewName = &newID
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RENAME TO %s`, id.FullyQualifiedName(), newID.FullyQualifiedName())
	})

	t.Run("alter: add column", func(t *testing.T) {
		opts := defaultOpts()
		opts.AddColumnAction = &HybridTableAddColumnAction{
			Name: "NEW_COLUMN",
			Type: DataTypeVARCHAR,
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ADD COLUMN NEW_COLUMN VARCHAR`, id.FullyQualifiedName())
	})

	t.Run("alter: add column with all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AddColumnAction = &HybridTableAddColumnAction{
			IfNotExists: Bool(true),
			Name:        "NEW_COLUMN",
			Type:        DataTypeVARCHAR,
			Collate:     String("utf8"),
			Comment:     String("new column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ADD COLUMN IF NOT EXISTS NEW_COLUMN VARCHAR COLLATE 'utf8' COMMENT 'new column comment'`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DropHybridTableOptions
	defaultOpts := func() *DropHybridTableOptions {
		return &DropHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.Cascade opts.Restrict]", func(t *testing.T) {
		opts := defaultOpts()
		opts.Cascade = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("DropHybridTableOptions", "Cascade", "Restrict"))
	})

	t.Run("drop", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options - cascade", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Cascade = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s CASCADE`, id.FullyQualifiedName())
	})

	t.Run("all options - restrict", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s RESTRICT`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Show(t *testing.T) {
	// Minimal valid ShowHybridTableOptions
	defaultOpts := func() *ShowHybridTableOptions {
		return &ShowHybridTableOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("show", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		opts.Like = &Like{Pattern: String("some_pattern")}
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("db", "schema")}
		opts.StartsWith = String("prefix")
		opts.Limit = &LimitFrom{Rows: Int(10)}
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE HYBRID TABLES LIKE 'some_pattern' IN SCHEMA "db"."schema" STARTS WITH 'prefix' LIMIT 10`)
	})

	t.Run("show with in database", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Database: NewAccountObjectIdentifier("test_db")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN DATABASE "test_db"`)
	})

	t.Run("show with in schema", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("test_db", "test_schema")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN SCHEMA "test_db"."test_schema"`)
	})

	t.Run("show with like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("pattern_test")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIKE 'pattern_test'`)
	})

	t.Run("show with limit", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{Rows: Int(10), From: String("table_name")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIMIT 10 FROM 'table_name'`)
	})
}

func TestHybridTables_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DescribeHybridTableOptions
	defaultOpts := func() *DescribeHybridTableOptions {
		return &DescribeHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("describe", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE TABLE %s`, id.FullyQualifiedName())
	})
}

func TestHybridTables_CreateIndex(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	tableID := randomSchemaObjectIdentifier()

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateHybridTableIndexOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			name:      emptySchemaObjectIdentifier,
			TableName: tableID,
			Columns:   []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.TableName]", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			name:      id,
			TableName: emptySchemaObjectIdentifier,
			Columns:   []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, errInvalidIdentifier("CreateHybridTableIndexOptions", "TableName"))
	})

	t.Run("validation: columns required", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			name:      id,
			TableName: tableID,
		}
		assertOptsInvalidJoinedErrors(t, opts, errNotSet("CreateHybridTableIndexOptions", "Columns"))
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			OrReplace:   Bool(true),
			IfNotExists: Bool(true),
			name:        id,
			TableName:   tableID,
			Columns:     []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateHybridTableIndexOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("create index", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			name:      id,
			TableName: tableID,
			Columns:   []string{"col1"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE INDEX %s ON %s (col1)`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			OrReplace:      Bool(true),
			name:           id,
			TableName:      tableID,
			Columns:        []string{"col1", "col2"},
			IncludeColumns: []string{"col3"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE INDEX %s ON %s (col1, col2) INCLUDE (col3)`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})

	t.Run("if not exists", func(t *testing.T) {
		opts := &CreateHybridTableIndexOptions{
			IfNotExists: Bool(true),
			name:        id,
			TableName:   tableID,
			Columns:     []string{"col1"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE INDEX IF NOT EXISTS %s ON %s (col1)`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})
}

func TestHybridTables_DropIndex(t *testing.T) {
	id := randomSchemaObjectIdentifier()

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropHybridTableIndexOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := &DropHybridTableIndexOptions{
			name: emptySchemaObjectIdentifier,
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("drop index", func(t *testing.T) {
		opts := &DropHybridTableIndexOptions{
			name: id,
		}
		assertOptsValidAndSQLEquals(t, opts, `DROP INDEX %s`, id.FullyQualifiedName())
	})

	t.Run("if exists", func(t *testing.T) {
		opts := &DropHybridTableIndexOptions{
			IfExists: Bool(true),
			name:     id,
		}
		assertOptsValidAndSQLEquals(t, opts, `DROP INDEX IF EXISTS %s`, id.FullyQualifiedName())
	})
}

func TestHybridTables_ShowIndexes(t *testing.T) {
	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowHybridTableIndexesOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("show indexes", func(t *testing.T) {
		opts := &ShowHybridTableIndexesOptions{}
		assertOptsValidAndSQLEquals(t, opts, `SHOW INDEXES`)
	})

	t.Run("in table", func(t *testing.T) {
		tableID := randomSchemaObjectIdentifier()
		opts := &ShowHybridTableIndexesOptions{
			In: &ShowHybridTableIndexIn{
				Table: &tableID,
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW INDEXES IN TABLE %s`, tableID.FullyQualifiedName())
	})
}
