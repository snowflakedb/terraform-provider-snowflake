// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

func TestHybridTables_Create(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	defaultOpts := func() *CreateHybridTableOptions {
		return &CreateHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateHybridTableOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("create", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{
			Columns: []HybridTableColumn{
				{
					Name: "ID",
					Type: DataTypeNumber,
					InlineConstraint: &ColumnInlineConstraint{
						Name: String("pk_id"),
						Type: ColumnConstraintTypePrimaryKey,
					},
				},
				{
					Name:    "NAME",
					Type:    DataTypeVARCHAR,
					NotNull: Bool(true),
					Collate: String("en-ci"),
					Comment: String("the name"),
				},
				{
					Name: "REF_ID",
					Type: DataTypeNumber,
					InlineConstraint: &ColumnInlineConstraint{
						Type: ColumnConstraintTypeForeignKey,
						ForeignKey: &InlineForeignKey{
							TableName:  "other_table",
							ColumnName: []string{"ID"},
						},
					},
				},
			},
			OutOfLineConstraint: []HybridTableOutOfLineConstraint{
				{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"NAME"},
				},
			},
			OutOfLineIndex: []HybridTableOutOfLineIndex{
				{
					Name:           "idx_name",
					Columns:        []string{"NAME"},
					IncludeColumns: []string{"ID"},
				},
			},
		}
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE HYBRID TABLE %s ("ID" NUMBER CONSTRAINT pk_id PRIMARY KEY, "NAME" VARCHAR NOT NULL COLLATE 'en-ci' COMMENT 'the name', "REF_ID" NUMBER FOREIGN KEY FOREIGN KEY REFERENCES other_table (ID), UNIQUE ("NAME"), INDEX "idx_name" ("NAME") INCLUDE ("ID")) COMMENT = 'test comment'`, id.FullyQualifiedName())
	})

	t.Run("with columns and constraints", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{
			Columns: []HybridTableColumn{
				{
					Name: "ID",
					Type: DataTypeNumber,
					InlineConstraint: &ColumnInlineConstraint{
						Type: ColumnConstraintTypePrimaryKey,
					},
				},
				{
					Name:    "NAME",
					Type:    DataTypeVARCHAR,
					NotNull: Bool(true),
					Comment: String("the name"),
				},
			},
			OutOfLineConstraint: []HybridTableOutOfLineConstraint{
				{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"NAME"},
				},
			},
			OutOfLineIndex: []HybridTableOutOfLineIndex{
				{
					Name:    "idx_name",
					Columns: []string{"NAME"},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s ("ID" NUMBER PRIMARY KEY, "NAME" VARCHAR NOT NULL COMMENT 'the name', UNIQUE ("NAME"), INDEX "idx_name" ("NAME"))`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	defaultOpts := func() *AlterHybridTableOptions {
		return &AlterHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from alter actions should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions", "NewName", "AddColumnAction", "ConstraintAction", "AlterColumnAction", "DropColumnAction", "DropIndexAction", "ClusteringAction", "Set", "Unset"))
	})

	t.Run("validation: constraint action - exactly one of Add, Rename, Drop required", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions.ConstraintAction", "Add", "Rename", "Drop"))
	})

	t.Run("validation: drop constraint - exactly one constraint type required", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions.ConstraintAction.Drop", "ConstraintName", "PrimaryKey", "Unique", "ForeignKey"))
	})

	t.Run("validation: drop constraint - cascade and restrict are mutually exclusive", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				PrimaryKey: Bool(true),
				Cascade:    Bool(true),
				Restrict:   Bool(true),
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("AlterHybridTableOptions.ConstraintAction.Drop", "Cascade", "Restrict"))
	})

	t.Run("validation: exactly one field from [opts.AlterColumnAction.DropDefault opts.AlterColumnAction.SetDefault opts.AlterColumnAction.NotNullConstraint opts.AlterColumnAction.Type opts.AlterColumnAction.Comment opts.AlterColumnAction.UnsetComment] should be present", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName: "col1",
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions.AlterColumnAction", "DropDefault", "SetDefault", "NotNullConstraint", "Type", "Comment", "UnsetComment"))
	})

	t.Run("validation: alter column not null constraint - exactly one", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName:        "col1",
				NotNullConstraint: &HybridTableColumnNotNullConstraint{},
			},
		}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions.AlterColumnAction.NotNullConstraint", "SetNotNull", "DropNotNull"))
	})

	t.Run("validation: clustering action - exactly one", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{}
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions.ClusteringAction", "ClusterBy", "Recluster", "ChangeReclusterState", "DropClusteringKey"))
	})

	t.Run("validation: at least one of set fields", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{}
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterHybridTableOptions.Set", "DataRetentionTimeInDays", "MaxDataExtensionTimeInDays", "ChangeTracking", "DefaultDdlCollation", "EnableSchemaEvolution", "Contact", "Comment", "RowTimestamp"))
	})

	t.Run("validation: at least one of unset fields", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &HybridTableUnsetProperties{}
		assertOptsInvalidJoinedErrors(t, opts, errAtLeastOneOf("AlterHybridTableOptions.Unset", "DataRetentionTimeInDays", "MaxDataExtensionTimeInDays", "ChangeTracking", "DefaultDdlCollation", "EnableSchemaEvolution", "ContactPurpose", "Comment"))
	})

	t.Run("alter: set", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays:    Int(14),
			MaxDataExtensionTimeInDays: Int(28),
			ChangeTracking:             Bool(true),
			DefaultDdlCollation:        String("en-ci"),
			EnableSchemaEvolution:      Bool(true),
			Contact: []TableContact{
				{Purpose: "admin", Contact: "John"},
			},
			Comment:      String("updated comment"),
			RowTimestamp: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s SET DATA_RETENTION_TIME_IN_DAYS = 14 MAX_DATA_EXTENSION_TIME_IN_DAYS = 28 CHANGE_TRACKING = true DEFAULT_DDL_COLLATION = 'en-ci' ENABLE_SCHEMA_EVOLUTION = true CONTACT admin 'John' COMMENT = 'updated comment' ROW_TIMESTAMP = true`, id.FullyQualifiedName())
	})

	t.Run("alter: unset", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays:    Bool(true),
			MaxDataExtensionTimeInDays: Bool(true),
			ChangeTracking:             Bool(true),
			DefaultDdlCollation:        Bool(true),
			EnableSchemaEvolution:      Bool(true),
			Comment:                    Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s UNSET DATA_RETENTION_TIME_IN_DAYS MAX_DATA_EXTENSION_TIME_IN_DAYS CHANGE_TRACKING DEFAULT_DDL_COLLATION ENABLE_SCHEMA_EVOLUTION COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: unset contact", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &HybridTableUnsetProperties{
			ContactPurpose: String("admin"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s UNSET CONTACT admin`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column set comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName: "column1",
				Comment:    String("column comment"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ALTER COLUMN "column1" COMMENT 'column comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column unset comment", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName:   "column1",
				UnsetComment: Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ALTER COLUMN "column1" UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column drop default", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName:  "column1",
				DropDefault: Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN "column1" DROP DEFAULT`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column set not null", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName: "column1",
				NotNullConstraint: &HybridTableColumnNotNullConstraint{
					SetNotNull: Bool(true),
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN "column1" SET NOT NULL`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column drop not null", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName: "column1",
				NotNullConstraint: &HybridTableColumnNotNullConstraint{
					DropNotNull: Bool(true),
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN "column1" DROP NOT NULL`, id.FullyQualifiedName())
	})

	t.Run("alter: alter column set data type", func(t *testing.T) {
		dt := DataType("VARCHAR(200)")
		opts := defaultOpts()
		opts.AlterColumnAction = []HybridTableAlterColumnAction{
			{
				ColumnName: "column1",
				Type:       &dt,
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN "column1" SET DATA TYPE VARCHAR(200)`, id.FullyQualifiedName())
	})

	t.Run("alter: drop column", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.DropColumnAction = &HybridTableDropColumnAction{
			Columns: []string{"column_to_drop"},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP COLUMN "column_to_drop"`, id.FullyQualifiedName())
	})

	t.Run("alter: drop index", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IndexName: "idx_name",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP INDEX "idx_name"`, id.FullyQualifiedName())
	})

	t.Run("alter: add constraint unique", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Add: &HybridTableConstraintActionAdd{
				OutOfLineConstraint: HybridTableOutOfLineConstraint{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"col1", "col2"},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ADD UNIQUE ("col1", "col2")`, id.FullyQualifiedName())
	})

	t.Run("alter: add constraint foreign key", func(t *testing.T) {
		refTableId := randomSchemaObjectIdentifier()
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Add: &HybridTableConstraintActionAdd{
				OutOfLineConstraint: HybridTableOutOfLineConstraint{
					Name:    String("fk_ref"),
					Type:    ColumnConstraintTypeForeignKey,
					Columns: []string{"ref_id"},
					ForeignKey: &OutOfLineForeignKey{
						TableName:   refTableId,
						ColumnNames: []string{"id"},
					},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ADD CONSTRAINT "fk_ref" FOREIGN KEY ("ref_id") REFERENCES %s (id)`, id.FullyQualifiedName(), refTableId.FullyQualifiedName())
	})

	t.Run("alter: drop constraint by name", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ConstraintName: String("my_constraint"),
				Restrict:       Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP CONSTRAINT "my_constraint" RESTRICT`, id.FullyQualifiedName())
	})

	t.Run("alter: drop primary key", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				PrimaryKey: Bool(true),
				Cascade:    Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP PRIMARY KEY CASCADE`, id.FullyQualifiedName())
	})

	t.Run("alter: drop unique with columns", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				Unique:  Bool(true),
				Columns: []string{"col1"},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP UNIQUE ("col1")`, id.FullyQualifiedName())
	})

	t.Run("alter: drop foreign key with cascade", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ForeignKey: Bool(true),
				Columns:    []string{"col1", "col2"},
				Cascade:    Bool(true),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s DROP FOREIGN KEY ("col1", "col2") CASCADE`, id.FullyQualifiedName())
	})

	t.Run("alter: rename constraint", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.ConstraintAction = &HybridTableConstraintAction{
			Rename: &HybridTableConstraintActionRename{
				OldName: "old_constraint_name",
				NewName: "new_constraint_name",
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s RENAME CONSTRAINT "old_constraint_name" TO "new_constraint_name"`, id.FullyQualifiedName())
	})

	t.Run("alter: rename to", func(t *testing.T) {
		newID := randomSchemaObjectIdentifierInSchema(id.SchemaId())
		opts := defaultOpts()
		opts.NewName = &newID
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RENAME TO %s`, id.FullyQualifiedName(), newID.FullyQualifiedName())
	})

	t.Run("alter: add column", func(t *testing.T) {
		opts := defaultOpts()
		opts.AddColumnAction = &HybridTableAddColumnAction{
			Name: "NEW_COLUMN",
			Type: DataTypeVARCHAR,
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ADD COLUMN "NEW_COLUMN" VARCHAR`, id.FullyQualifiedName())
	})

	t.Run("alter: add column with all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.AddColumnAction = &HybridTableAddColumnAction{
			IfNotExists: Bool(true),
			Name:        "NEW_COLUMN",
			Type:        DataTypeVARCHAR,
			Collate:     String("utf8"),
			InlineConstraint: &ColumnInlineConstraint{
				Name: String("uq_new"),
				Type: ColumnConstraintTypeUnique,
			},
			Comment: String("new column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s ADD COLUMN IF NOT EXISTS "NEW_COLUMN" VARCHAR COLLATE 'utf8' CONSTRAINT uq_new UNIQUE COMMENT 'new column comment'`, id.FullyQualifiedName())
	})

	t.Run("alter: cluster by", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			ClusterBy: []string{"col1", "col2"},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s CLUSTER BY (col1, col2)`, id.FullyQualifiedName())
	})

	t.Run("alter: recluster", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			Recluster: &HybridTableReclusterAction{},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RECLUSTER`, id.FullyQualifiedName())
	})

	t.Run("alter: recluster with options", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			Recluster: &HybridTableReclusterAction{
				MaxSize: Int(1000),
				Where:   String("col1 > 100"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RECLUSTER MAX_SIZE = 1000 WHERE col1 > 100`, id.FullyQualifiedName())
	})

	t.Run("alter: suspend recluster", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			ChangeReclusterState: &HybridTableReclusterChangeState{
				State: Pointer(ReclusterStateSuspend),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s SUSPEND RECLUSTER`, id.FullyQualifiedName())
	})

	t.Run("alter: resume recluster", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			ChangeReclusterState: &HybridTableReclusterChangeState{
				State: Pointer(ReclusterStateResume),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RESUME RECLUSTER`, id.FullyQualifiedName())
	})

	t.Run("alter: drop clustering key", func(t *testing.T) {
		opts := defaultOpts()
		opts.ClusteringAction = &HybridTableClusteringAction{
			DropClusteringKey: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP CLUSTERING KEY`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	defaultOpts := func() *DropHybridTableOptions {
		return &DropHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.Cascade opts.Restrict]", func(t *testing.T) {
		opts := defaultOpts()
		opts.Cascade = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("DropHybridTableOptions", "Cascade", "Restrict"))
	})

	t.Run("drop", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options - cascade", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Cascade = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s CASCADE`, id.FullyQualifiedName())
	})

	t.Run("all options - restrict", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s RESTRICT`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Show(t *testing.T) {
	defaultOpts := func() *ShowHybridTableOptions {
		return &ShowHybridTableOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("show", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		opts.Like = &Like{Pattern: String("some_pattern")}
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("db", "schema")}
		opts.StartsWith = String("prefix")
		opts.Limit = &LimitFrom{Rows: Int(10)}
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE HYBRID TABLES LIKE 'some_pattern' IN SCHEMA "db"."schema" STARTS WITH 'prefix' LIMIT 10`)
	})

	t.Run("show with in database", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Database: NewAccountObjectIdentifier("test_db")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN DATABASE "test_db"`)
	})

	t.Run("show with in schema", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("test_db", "test_schema")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN SCHEMA "test_db"."test_schema"`)
	})

	t.Run("show with like", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("pattern_test")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIKE 'pattern_test'`)
	})

	t.Run("show with limit", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{Rows: Int(10), From: String("table_name")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIMIT 10 FROM 'table_name'`)
	})
}

func TestHybridTables_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	defaultOpts := func() *DescribeHybridTableOptions {
		return &DescribeHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("describe", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE TABLE %s`, id.FullyQualifiedName())
	})
}

func TestHybridTables_CreateIndex(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	tableID := randomSchemaObjectIdentifier()

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateIndexHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			name:      emptySchemaObjectIdentifier,
			TableName: tableID,
			Columns:   []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: valid identifier for [opts.TableName]", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			name:      id,
			TableName: emptySchemaObjectIdentifier,
			Columns:   []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			OrReplace:   Bool(true),
			IfNotExists: Bool(true),
			name:        id,
			TableName:   tableID,
			Columns:     []string{"col1"},
		}
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateIndexHybridTableOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("create index", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			name:      id,
			TableName: tableID,
			Columns:   []string{"col1"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE INDEX %s ON %s ("col1")`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			OrReplace:      Bool(true),
			name:           id,
			TableName:      tableID,
			Columns:        []string{"col1", "col2"},
			IncludeColumns: []string{"col3"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE INDEX %s ON %s ("col1", "col2") INCLUDE ("col3")`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})

	t.Run("if not exists", func(t *testing.T) {
		opts := &CreateIndexHybridTableOptions{
			IfNotExists: Bool(true),
			name:        id,
			TableName:   tableID,
			Columns:     []string{"col1"},
		}
		assertOptsValidAndSQLEquals(t, opts, `CREATE INDEX IF NOT EXISTS %s ON %s ("col1")`, id.FullyQualifiedName(), tableID.FullyQualifiedName())
	})
}

func TestHybridTables_DropIndex(t *testing.T) {
	id := randomSchemaObjectIdentifier()

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropIndexHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := &DropIndexHybridTableOptions{
			name: emptySchemaObjectIdentifier,
		}
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("drop index", func(t *testing.T) {
		opts := &DropIndexHybridTableOptions{
			name: id,
		}
		assertOptsValidAndSQLEquals(t, opts, `DROP INDEX %s`, id.FullyQualifiedName())
	})

	t.Run("if exists", func(t *testing.T) {
		opts := &DropIndexHybridTableOptions{
			IfExists: Bool(true),
			name:     id,
		}
		assertOptsValidAndSQLEquals(t, opts, `DROP INDEX IF EXISTS %s`, id.FullyQualifiedName())
	})
}

func TestHybridTables_ShowIndexes(t *testing.T) {
	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowIndexesHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("show indexes", func(t *testing.T) {
		opts := &ShowIndexesHybridTableOptions{}
		assertOptsValidAndSQLEquals(t, opts, `SHOW INDEXES`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := &ShowIndexesHybridTableOptions{
			Like:       &Like{Pattern: String("idx_pattern")},
			In:         &In{Schema: NewDatabaseObjectIdentifier("db", "schema")},
			StartsWith: String("idx_"),
			Limit:      &LimitFrom{Rows: Int(10)},
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW INDEXES LIKE 'idx_pattern' IN SCHEMA "db"."schema" STARTS WITH 'idx_' LIMIT 10`)
	})

	t.Run("in database", func(t *testing.T) {
		opts := &ShowIndexesHybridTableOptions{
			In: &In{Database: NewAccountObjectIdentifier("test_db")},
		}
		assertOptsValidAndSQLEquals(t, opts, `SHOW INDEXES IN DATABASE "test_db"`)
	})
}
