// Code generated by SDK builder generator (v0.1.0); DO NOT EDIT.

package sdk

import (
	"testing"
)

func TestHybridTables_Create(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid CreateHybridTableOptions
	defaultOpts := func() *CreateHybridTableOptions {
		return &CreateHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*CreateHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: conflicting fields for [opts.OrReplace opts.IfNotExists]", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.IfNotExists = Bool(true)
		assertOptsInvalidJoinedErrors(t, opts, errOneOf("CreateHybridTableOptions", "OrReplace", "IfNotExists"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		opts.DataRetentionTimeInDays = Int(7)
		opts.Comment = String("test comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE HYBRID TABLE %s DATA_RETENTION_TIME_IN_DAYS = 7 COMMENT = 'test comment'`, id.FullyQualifiedName())
	})

	t.Run("with OR REPLACE", func(t *testing.T) {
		opts := defaultOpts()
		opts.OrReplace = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE OR REPLACE HYBRID TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("with IF NOT EXISTS", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfNotExists = Bool(true)
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE IF NOT EXISTS %s`, id.FullyQualifiedName())
	})

	t.Run("with COMMENT", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		opts.Comment = String("table comment")
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s COMMENT = 'table comment'`, id.FullyQualifiedName())
	})

	t.Run("with DATA_RETENTION_TIME_IN_DAYS", func(t *testing.T) {
		opts := defaultOpts()
		opts.ColumnsAndConstraints = HybridTableColumnsConstraintsAndIndexes{}
		opts.DataRetentionTimeInDays = Int(0)
		assertOptsValidAndSQLEquals(t, opts, `CREATE HYBRID TABLE %s DATA_RETENTION_TIME_IN_DAYS = 0`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Alter(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid AlterHybridTableOptions
	defaultOpts := func() *AlterHybridTableOptions {
		return &AlterHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*AlterHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("validation: exactly one field from [opts.ConstraintAction opts.AlterColumnAction opts.DropColumnAction opts.DropIndexAction opts.BuildIndexAction opts.Set opts.Unset] should be present", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsInvalidJoinedErrors(t, opts, errExactlyOneOf("AlterHybridTableOptions", "ConstraintAction", "AlterColumnAction", "DropColumnAction", "DropIndexAction", "BuildIndexAction", "Set", "Unset"))
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{
			Comment: String("new comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s SET COMMENT = 'new comment'`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays: Int(14),
			Comment:                 String("updated comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE IF EXISTS %s SET DATA_RETENTION_TIME_IN_DAYS = 14 COMMENT = 'updated comment'`, id.FullyQualifiedName())
	})

	t.Run("ALTER COLUMN SET COMMENT", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName: "column1",
			Comment:    String("column comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN column1 COMMENT 'column comment'`, id.FullyQualifiedName())
	})

	t.Run("ALTER COLUMN UNSET COMMENT", func(t *testing.T) {
		opts := defaultOpts()
		opts.AlterColumnAction = &HybridTableAlterColumnAction{
			ColumnName:   "column1",
			UnsetComment: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ALTER COLUMN column1 UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("DROP COLUMN", func(t *testing.T) {
		opts := defaultOpts()
		opts.DropColumnAction = &HybridTableDropColumnAction{
			ColumnName: "column_to_drop",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP COLUMN column_to_drop`, id.FullyQualifiedName())
	})

	t.Run("DROP INDEX", func(t *testing.T) {
		opts := defaultOpts()
		opts.DropIndexAction = &HybridTableDropIndexAction{
			IndexName: "idx_name",
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP INDEX idx_name`, id.FullyQualifiedName())
	})

	t.Run("BUILD INDEX with FENCE", func(t *testing.T) {
		opts := defaultOpts()
		opts.BuildIndexAction = &HybridTableBuildIndexAction{
			IndexName: "idx_name",
			Fence:     Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s BUILD INDEX idx_name FENCE`, id.FullyQualifiedName())
	})

	t.Run("BUILD INDEX with BACKFILL", func(t *testing.T) {
		opts := defaultOpts()
		opts.BuildIndexAction = &HybridTableBuildIndexAction{
			IndexName: "idx_name",
			Backfill:  Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s BUILD INDEX idx_name BACKFILL`, id.FullyQualifiedName())
	})

	t.Run("BUILD INDEX with FENCE and BACKFILL", func(t *testing.T) {
		opts := defaultOpts()
		opts.BuildIndexAction = &HybridTableBuildIndexAction{
			IndexName: "idx_name",
			Fence:     Bool(true),
			Backfill:  Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s BUILD INDEX idx_name FENCE BACKFILL`, id.FullyQualifiedName())
	})

	t.Run("SET DATA_RETENTION_TIME_IN_DAYS", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{
			DataRetentionTimeInDays: Int(7),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s SET DATA_RETENTION_TIME_IN_DAYS = 7`, id.FullyQualifiedName())
	})

	t.Run("SET COMMENT", func(t *testing.T) {
		opts := defaultOpts()
		opts.Set = &HybridTableSetProperties{
			Comment: String("new comment"),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s SET COMMENT = 'new comment'`, id.FullyQualifiedName())
	})

	t.Run("UNSET DATA_RETENTION_TIME_IN_DAYS", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &HybridTableUnsetProperties{
			DataRetentionTimeInDays: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s UNSET DATA_RETENTION_TIME_IN_DAYS`, id.FullyQualifiedName())
	})

	t.Run("UNSET COMMENT", func(t *testing.T) {
		opts := defaultOpts()
		opts.Unset = &HybridTableUnsetProperties{
			Comment: Bool(true),
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s UNSET COMMENT`, id.FullyQualifiedName())
	})

	t.Run("ADD CONSTRAINT UNIQUE", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Add: &HybridTableConstraintActionAdd{
				OutOfLineConstraint: HybridTableOutOfLineConstraint{
					Type:    ColumnConstraintTypeUnique,
					Columns: []string{"col1", "col2"},
				},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s ADD UNIQUE (col1, col2)`, id.FullyQualifiedName())
	})

	t.Run("DROP CONSTRAINT by name", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ConstraintName: String("constraint_name"),
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP CONSTRAINT constraint_name`, id.FullyQualifiedName())
	})

	t.Run("DROP CONSTRAINT by type", func(t *testing.T) {
		opts := defaultOpts()
		constraintType := ColumnConstraintTypeUnique
		opts.ConstraintAction = &HybridTableConstraintAction{
			Drop: &HybridTableConstraintActionDrop{
				ColumnConstraintType: &constraintType,
				Columns:              []string{"col1"},
			},
		}
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s DROP UNIQUE (col1)`, id.FullyQualifiedName())
	})

	t.Run("RENAME CONSTRAINT", func(t *testing.T) {
		opts := defaultOpts()
		opts.ConstraintAction = &HybridTableConstraintAction{
			Rename: &HybridTableConstraintActionRename{
				OldName: "old_constraint_name",
				NewName: "new_constraint_name",
			},
		}
		// Note: Generator doesn't add "TO" keyword despite sql:"TO" tag
		assertOptsValidAndSQLEquals(t, opts, `ALTER TABLE %s RENAME CONSTRAINT old_constraint_name new_constraint_name`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Drop(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DropHybridTableOptions
	defaultOpts := func() *DropHybridTableOptions {
		return &DropHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DropHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		opts.Restrict = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s RESTRICT`, id.FullyQualifiedName())
	})

	t.Run("with IF EXISTS", func(t *testing.T) {
		opts := defaultOpts()
		opts.IfExists = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE IF EXISTS %s`, id.FullyQualifiedName())
	})

	t.Run("with RESTRICT", func(t *testing.T) {
		opts := defaultOpts()
		opts.Restrict = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `DROP TABLE %s RESTRICT`, id.FullyQualifiedName())
	})
}

func TestHybridTables_Show(t *testing.T) {
	// Minimal valid ShowHybridTableOptions
	defaultOpts := func() *ShowHybridTableOptions {
		return &ShowHybridTableOptions{}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*ShowHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES`)
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		opts.Like = &Like{Pattern: String("some_pattern")}
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("db", "schema")}
		opts.StartsWith = String("prefix")
		opts.Limit = &LimitFrom{Rows: Int(10)}
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE HYBRID TABLES LIKE 'some_pattern' IN SCHEMA "db"."schema" STARTS WITH 'prefix' LIMIT 10`)
	})

	t.Run("with TERSE", func(t *testing.T) {
		opts := defaultOpts()
		opts.Terse = Bool(true)
		assertOptsValidAndSQLEquals(t, opts, `SHOW TERSE HYBRID TABLES`)
	})

	t.Run("with LIKE", func(t *testing.T) {
		opts := defaultOpts()
		opts.Like = &Like{Pattern: String("pattern_test")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIKE 'pattern_test'`)
	})

	t.Run("with IN DATABASE", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Database: NewAccountObjectIdentifier("test_db")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN DATABASE "test_db"`)
	})

	t.Run("with IN SCHEMA", func(t *testing.T) {
		opts := defaultOpts()
		opts.In = &In{Schema: NewDatabaseObjectIdentifier("test_db", "test_schema")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES IN SCHEMA "test_db"."test_schema"`)
	})

	t.Run("with STARTS WITH", func(t *testing.T) {
		opts := defaultOpts()
		opts.StartsWith = String("test_prefix")
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES STARTS WITH 'test_prefix'`)
	})

	t.Run("with LIMIT", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{Rows: Int(5)}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIMIT 5`)
	})

	t.Run("with LIMIT FROM", func(t *testing.T) {
		opts := defaultOpts()
		opts.Limit = &LimitFrom{Rows: Int(10), From: String("table_name")}
		assertOptsValidAndSQLEquals(t, opts, `SHOW HYBRID TABLES LIMIT 10 FROM 'table_name'`)
	})
}

func TestHybridTables_Describe(t *testing.T) {
	id := randomSchemaObjectIdentifier()
	// Minimal valid DescribeHybridTableOptions
	defaultOpts := func() *DescribeHybridTableOptions {
		return &DescribeHybridTableOptions{
			name: id,
		}
	}

	t.Run("validation: nil options", func(t *testing.T) {
		opts := (*DescribeHybridTableOptions)(nil)
		assertOptsInvalidJoinedErrors(t, opts, ErrNilOptions)
	})

	t.Run("validation: valid identifier for [opts.name]", func(t *testing.T) {
		opts := defaultOpts()
		opts.name = emptySchemaObjectIdentifier
		assertOptsInvalidJoinedErrors(t, opts, ErrInvalidObjectIdentifier)
	})

	t.Run("basic", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE TABLE %s`, id.FullyQualifiedName())
	})

	t.Run("all options", func(t *testing.T) {
		opts := defaultOpts()
		assertOptsValidAndSQLEquals(t, opts, `DESCRIBE TABLE %s`, id.FullyQualifiedName())
	})
}
