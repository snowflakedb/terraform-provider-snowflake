---
page_title: "{{.Name}} {{.Type}} - {{.ProviderName}}"
subcategory: "Preview"
description: |-
{{ if gt (len (split .Description "<deprecation>")) 1 -}}
{{ index (split .Description "<deprecation>") 1 | plainmarkdown | trimspace | prefixlines "  " }}
{{- else -}}
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
{{- end }}
---

!> **Caution: Preview Feature** This feature is considered a preview feature in the provider, regardless of the state of the resource in Snowflake. We do not guarantee its stability. It will be reworked and marked as a stable feature in future releases. Breaking changes are expected, even without bumping the major version. To use this feature, add the relevant feature name to `preview_features_enabled` field in the [provider configuration](https://registry.terraform.io/providers/snowflakedb/snowflake/latest/docs#schema). Please always refer to the [Getting Help](https://github.com/snowflakedb/terraform-provider-snowflake?tab=readme-ov-file#getting-help) section in our Github repo to best determine how to get help for your questions.

-> **Note** Read more about PAT support in the provider in our [Authentication Methods guide](../guides/authentication_methods#managing-pats).

-> **Note** External changes to `mins_to_bypass_network_policy_requirement` are not handled by the provider because the value changes continuously on Snowflake side after setting it.

-> **Note** External changes to `days_to_expiry` are not handled by the provider because Snowflake returns `expires_at` which is the token expiration date. Also, the provider does not handle expired tokens automatically. Please change the value of `days_to_expiry` to force a new expiration date.

-> **Note** External changes to `token` are not handled by the provider because the data in this field can be updated only when the token is created or rotated.

-> **Note** Rotating a token can be done by changing the value of `keeper` field. See an example below.

-> **Note** In order to authenticate with PAT with role restriction, you need to grant the role to the user. You can use the [snowflake_grant_account_role](./grant_account_role) resource to do this.

# {{.Name}} ({{.Type}})

{{ .Description | trimspace }}

{{ if .HasExample -}}
## Example Usage

-> **Note** Instead of using fully_qualified_name, you can reference objects managed outside Terraform by constructing a correct ID, consult [identifiers guide](../guides/identifiers_rework_design_decisions#new-computed-fully-qualified-name-field-in-resources).
<!-- TODO(SNOW-1634854): include an example showing both methods-->

{{ tffile .ExampleFile }}

## Token rotation clarifications
The token value returned from Snowflake is stored in the Terraform state and can stay constant until the `keeper` field is changed from a non-empty to a different non-empty value (or is known after apply).
Then, the token is rotated and the new `token` value is stored in the state. In this case, the `token` and `rotated_token_name` fields are marked as computed.
You can use the `keeper` argument in this resource to store an arbitrary string. Fill it with a value that should persist unless you want a new token.
The key gets is not rotated when the `keeper` field is added to or removed from the configuration.
Keep in mind that `keeper` isn't treated as sensitive data, so any values you use for this field will appear as plain text in the Terraform outputs.

In the example above, when you first add a `keeper` field, you will see a plan output similar to:
```
time_rotating.rotation_schedule: Refreshing state... [id=2025-07-22T07:59:20Z]
snowflake_user_programmatic_access_token.complete_with_external_references: Refreshing state... [id="PAT"|"TOKEN"]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # snowflake_user_programmatic_access_token.complete_with_external_references will be updated in-place
  ~ resource "snowflake_user_programmatic_access_token" "complete_with_external_references" {
        id                                        = "\"PAT\"|\"TOKEN\""
      + keeper                                    = "2025-07-22T07:59:20Z"
        name                                      = "TOKEN"
        # (9 unchanged attributes hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.
```
This plan means that the value of `keeper` is saved in the state, but the token will not be rotated yet.
After 30 days pass, the `rotation_schedule` resource will return a new timestamp. So, the value of the `keeper` field is changed automatically.
You will see a plan output similar to:
```
time_rotating.rotation_schedule: Refreshing state... [id=2025-07-22T08:06:51Z]
snowflake_user_programmatic_access_token.complete_with_external_references: Refreshing state... [id="PAT"|"TOKEN"]

Note: Objects have changed outside of Terraform

Terraform detected the following changes made outside of Terraform since the last "terraform apply" which may have affected this plan:

  # time_rotating.rotation_schedule has been deleted
  - resource "time_rotating" "rotation_schedule" {
        id               = "2025-07-22T08:06:51Z"
      - rfc3339          = "2025-07-22T08:06:51Z" -> null
        # (9 unchanged attributes hidden)
    }


Unless you have made equivalent changes to your configuration, or ignored the relevant attributes using ignore_changes, the following plan may include actions to undo or respond to
these changes.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
  ~ update in-place

Terraform will perform the following actions:

  # snowflake_user_programmatic_access_token.complete_with_external_references will be updated in-place
  ~ resource "snowflake_user_programmatic_access_token" "complete_with_external_references" {
        id                                        = "\"PAT\"|\"TOKEN\""
      ~ keeper                                    = "2025-07-22T08:06:51Z" -> (known after apply)
        name                                      = "TOKEN"
      + rotated_token_name                        = (known after apply)
      ~ token                                     = (sensitive value)
        # (8 unchanged attributes hidden)
    }

  # time_rotating.rotation_schedule will be created
  + resource "time_rotating" "rotation_schedule" {
      + day              = 30
      + hour             = (known after apply)
      + id               = (known after apply)
      + minute           = (known after apply)
      + month            = (known after apply)
      + rfc3339          = (known after apply)
      + rotation_minutes = (known after apply)
      + rotation_rfc3339 = (known after apply)
      + second           = (known after apply)
      + unix             = (known after apply)
      + year             = (known after apply)
    }

Plan: 1 to add, 1 to change, 0 to destroy.
```
After you apply this plan, the token will be rotated and the new `token` value will be stored in the state each time the value of `time_rotating.rotation_schedule.rotation_rfc3339` is changed.
When you remove the `keeper` field from the configuration, the token will not be rotated, see the plan output below:
```
time_rotating.rotation_schedule: Refreshing state... [id=2025-07-22T08:06:51Z]
snowflake_user_programmatic_access_token.complete_with_external_references: Refreshing state... [id="PAT"|"TOKEN"]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
  ~ update in-place

Terraform will perform the following actions:

  # snowflake_user_programmatic_access_token.complete_with_external_references will be updated in-place
  ~ resource "snowflake_user_programmatic_access_token" "complete_with_external_references" {
        id                                        = "\"PAT\"|\"TOKEN\""
      - keeper                                    = "2025-07-22T08:06:51Z" -> null
        name                                      = "TOKEN"
        # (9 unchanged attributes hidden)
    }

  # time_rotating.rotation_schedule will be created
  + resource "time_rotating" "rotation_schedule" {
      + day              = 30
      + hour             = (known after apply)
      + id               = (known after apply)
      + minute           = (known after apply)
      + month            = (known after apply)
      + rfc3339          = (known after apply)
      + rotation_minutes = (known after apply)
      + rotation_rfc3339 = (known after apply)
      + second           = (known after apply)
      + unix             = (known after apply)
      + year             = (known after apply)
    }

Plan: 1 to add, 1 to change, 0 to destroy.
```

This way you can cancel the rotation schedule without rotating the token (the `token` and `rotated_token_name` fields are not marked as computed).

{{- end }}

-> **Note** If a field has a default value, it is shown next to the type in the schema.

{{ .SchemaMarkdown | trimspace }}
{{- if .HasImport }}

## Import

Import is supported using the following syntax:

{{ codefile "shell" (printf "examples/resources/%s/import.sh" .Name)}}
{{- end }}
